[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Les statistiques avec R",
    "section": "",
    "text": "Préface\nCeci est un livre Quarto.\nPour en apprendre davantage sur Quarto, visitez https://quarto.org/docs/books.",
    "crumbs": [
      "Préface"
    ]
  },
  {
    "objectID": "tidyverse.html",
    "href": "tidyverse.html",
    "title": "1  Le tidyverse",
    "section": "",
    "text": "1.1 Extensions\nLe terme tidyverse est une contraction de tidy (qu’on pourrait traduire par bien rangé) et de universe. En allant visiter le site internet de ces extensions https://www.tidyverse.org/, voici ce que nous pouvons trouver sur la première page du site:\nque nous pourrions traduire par:\nCes extensions abordent un très grand nombre d’opérations courantes dans R. L’avantage d’utiliser le tidyverse c’est qu’il permet de simplifier plusieurs opérations fréquentes et il introduit le concept de tidy data. De plus, la grammaire du tidyverse étant cohérente entre toutes ses extensions, en apprenant comment utiliser l’une de ces extensions, vous serez en monde connu lorsque viendra le temps d’apprendre de nouvelles extensions.\nNous utiliserons le tidyverse pour:\nLe tidyverse permet aussi de:\nPour en savoir plus, nous invitons le lecteur à se rendre au site du tidyverse https://www.tidyverse.org/. Le tidyverse est en grande partie issu des travaux de Hadley Wickham.",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le tidyverse</span>"
    ]
  },
  {
    "objectID": "tidyverse.html#extensions",
    "href": "tidyverse.html#extensions",
    "title": "1  Le tidyverse",
    "section": "",
    "text": "The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\n\n\n\nLe tidyverse est une collection dogmatique d’extensions pour le langage R conçues pour la science des données. Toutes les extensions partagent une philosphie sous-jacente de design, de grammaire et de structures de données.\n\n\n\n\nLe concept de tidy data\nL’importation et/ou l’exportation de données\nLa manipulation de variables\nLa visualisation\n\n\n\nTravailler avec des chaînes de caractères (du texte par exemple)\nProgrammer\nRemettre en forme des données\nExtraire des données du Web\nEtc.",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le tidyverse</span>"
    ]
  },
  {
    "objectID": "tidyverse.html#tidydata",
    "href": "tidyverse.html#tidydata",
    "title": "1  Le tidyverse",
    "section": "1.2 Les tidy data",
    "text": "1.2 Les tidy data\nLe tidyverse est en partie fondé sur le concept de tidy data, développé à l’origine par Hadley Wickham dans un article du Journal of Statistical Software. Nous pourrions traduire ce concept par données bien rangées.\nIl s’agit d’un modèle d’organisation des données qui vise à faciliter le travail souvent long et fastidieux de nettoyage et de préparation préalable à la mise en oeuvre de méthodes d’analyse. Dans ce livre, nous travaillerons toujours avec des tidy data. En réalité, la plupart des données rencontrées par les chercheurs ne sont pas tidy. Il existe une extension du tidyverse qui permet de faciliter la transformation de données non tidy en données tidy, l’extension tidyr. Nous ne verrons pas comment l’utiliser dans ce livre.\nLes principes d’un jeu de données tidy sont les suivants :\n\nchaque variable est une colonne\nchaque observation est une ligne\nchaque valeur doit être dans une cellule différente\n\nLa Figure 1.1 montre ces règles de façon visuelle.\n\n\n\n\n\n\nFigure 1.1: Suivre les trois principes rend les données tidy: les variables sont en colonnes, les observations sont sur des lignes, et chaques valeurs sont dans des cellules différentes.\n\n\n\nPourquoi s’assurer que vos données sont tidy? Il y a deux avantages importants:\n\nUn avantage général de choisir une seule façon de conserver vos données. Si vous utilisez une structure de données consitante, il est plus facile d’apprendre à utiliser les outils qui fonctionneront avec ce type de structure, étant donné que celles-ci possède une uniformité sous-jacente.\nUn avantage spécifique de placer les variables en colonnes car ceci permet de vectoriser les opérations dans R. Ceci implique que vos fonctions seront plus rapides lorsque viendra le temps de les exécuter.\n\nVoici un exemple de données tidy qui sont accessibles dans la librairie tidyverse.\n\ndiamonds\n#&gt; # A tibble: 53,940 × 10\n#&gt;    carat cut       color clarity depth table price     x     y     z\n#&gt;    &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt;  2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt;  3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt;  4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt;  5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt;  6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt;  7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n#&gt;  8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n#&gt;  9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n#&gt; 10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n#&gt; # ℹ 53,930 more rows",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le tidyverse</span>"
    ]
  },
  {
    "objectID": "tidyverse.html#tibbles",
    "href": "tidyverse.html#tibbles",
    "title": "1  Le tidyverse",
    "section": "1.3 Les tibbles",
    "text": "1.3 Les tibbles\nUne autre particularité du tidyverse est que ces extensions travaillent avec des tableaux de données au format tibble, qui est une évolution plus moderne du classique data frame du R de base. Ce format est fourni est géré par l’extension du même nom (tibble), qui fait partie du coeur du tidyverse. La plupart des fonctions des extensions du tidyverse acceptent des data frames en entrée, mais retournent un objet de classe tibble.\nPour être en mesure d’effectuer des calculs statistiques, il nous faut une structure qui soit en mesure de garder en mémoire une base de données. Ces structures se nomment des “tibbles” dans R.\n\n1.3.1 Un exemple de tibble\nPour comprendre ce qu’est un tibble, nous allons utiliser deux librairies: nycflights13 et diamonds. Si ce n’est pas déjà fait, vous devez les installer et ensuite les charger.\n\nlibrary(nycflights13)\nlibrary(ggplot2)\n\nNous allons étudier le paquetage nycflights13qui contient 5 bases de données contenant des informations concernant les vols intérieurs en partance de New York en 2013, à partir des aéroports de Newark Liberty International (EWR), John F. Kennedy International (JFK) ou LaGuardia (LGA). Les 5 bases de données sont les suivantes:\n\nflights: information sur les 336,776 vols\nairlines: lien entre les codes IATA de deux lettres et les noms de compagnies d’aviation (16 au total)\nplanes: information de construction sur les 3 322 avions utilisés\nweather: données météo à chaque heure (environ 8 710 observations) pour chacun des trois aéroports.\nairports: noms des aéroports et localisations\n\n\n\n1.3.2 La base de données flights\nPour visualiser facilement une base de données sous forme tibble, il suffit de taper son nom dans la console. Nous allons utiliser la base de données flights. Par exemple:\n\nflights\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     1      533            529         4      850            830\n#&gt;  3  2013     1     1      542            540         2      923            850\n#&gt;  4  2013     1     1      544            545        -1     1004           1022\n#&gt;  5  2013     1     1      554            600        -6      812            837\n#&gt;  6  2013     1     1      554            558        -4      740            728\n#&gt;  7  2013     1     1      555            600        -5      913            854\n#&gt;  8  2013     1     1      557            600        -3      709            723\n#&gt;  9  2013     1     1      557            600        -3      838            846\n#&gt; 10  2013     1     1      558            600        -2      753            745\n#&gt; # ℹ 336,766 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nNous allons décortiquer la sortie console:\n\nA tibble: 336,776 x 19: un tibble est une façon de représenter une base de données en R. Cette base de données possède:\n\n336 776 lignes\n19 colonnes correspondant aux 19 variables décrivant chacune des observations\n\nyear month day dep_time sched_dep_time dep_delay arr_time sont différentes colonnes, en d’autres mots des variables, de cette base de données.\nNous avons ensuite 10 lignes d’obervations correspondant à 10 vols\n... with 336,766 more rows, and 12 more variables: nous indique que 336 766 lignes et 12 autres variables ne pouvaient pas être affichées à l’écran.\n\nMalheureusement cette sortie écran ne nous permet pas d’explorer les données correctement. Nous verrons à la section @ref(explorertibbles) comment explorer des tibbles.\n\n\n1.3.3 La base de données diamonds\nLa base de données diamonds est composée des variables suivantes:\n\nprice : prix en dollars US\ncarat : poids du diamant en grammes\ncut : qualité de la coupe (Fair, Good, Very Good, Premium, Ideal)\ncolor : couleur du diamant (J (pire) jusqu’à D (meilleur))\nclarity : une mesure de la clarté du diamant (I1 (pire), SI2, SI1, VS2, VS1, VVS2, VVS1, IF (meilleur))\nx : longueur en mm\ny : largeur en mm\nz : hauteur en mm\ndepth : z / mean(x, y) = 2 * z / (x + y)\ntable : largeur du dessus du diamant par rapport à son point le plus large\n\n\ndiamonds\n#&gt; # A tibble: 53,940 × 10\n#&gt;    carat cut       color clarity depth table price     x     y     z\n#&gt;    &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt;  2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt;  3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt;  4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt;  5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt;  6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt;  7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n#&gt;  8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n#&gt;  9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n#&gt; 10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n#&gt; # ℹ 53,930 more rows\n\n\n\n1.3.4 Comment explorer des “tibbles”\nVoici les façons les plus communes de comprendre les données se trouvant à l’intérieur d’un “tibble”:\n\nEn utilisant la fonction View() de RStudio.C’est la commande que nous utiliserons le plus fréquemment.\nEn utilisant la fonction glimpse().\nEn utilisant l’opérateur $ pour étudier une seule variable d’une base de données.\n\nVoici comment utiliser ces fonctions.\n\nView(): Éxécutez View(flights) dans la console de RStudio et explorez la base de données obtenue.\n\nNous remarquons que chaque colonnes représentent une variable différente et que ces variables peuvent être de différents types. Certaines de ces variables, comme distance, day et arr_delay sont des variables dites quantitatives. Ces variables sont numériques par nature. D’autres variables sont dites qualitatives.\nSi vous regardez la colonne à l’extrème-gauche de la sortie de View(flights), vous verrez une colonne de nombres. Ces nombres représentent les numéros de ligne de la base de données. Si vous vous promenez sur une ligne de même nombre, par exemple la ligne 5, vous étudiez une unité statistique.\n\nglimpse:\n\nLa seconde façon d’explorer une base de données est d’utiliser la fonction glimpse(). Cette fonction nous donne la majorité de l’information précédente et encore plus.\n\nglimpse(flights)\n#&gt; Rows: 336,776\n#&gt; Columns: 19\n#&gt; $ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n#&gt; $ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#&gt; $ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n#&gt; $ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n#&gt; $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n#&gt; $ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n#&gt; $ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n#&gt; $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n#&gt; $ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n#&gt; $ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n#&gt; $ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n#&gt; $ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n#&gt; $ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n#&gt; $ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n#&gt; $ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n#&gt; $ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n#&gt; $ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n#&gt; $ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n#&gt; $ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\nL’opérateur $:\n\nFinalement, l’opérateur $ nous permet d’explorer une seule variable à l’intérieur d’une base de données. Par exemple, si nous désirons étudier la variable name de la base de données airlines, nous obtenons:\n\nairlines$name\n#&gt;  [1] \"Endeavor Air Inc.\"           \"American Airlines Inc.\"     \n#&gt;  [3] \"Alaska Airlines Inc.\"        \"JetBlue Airways\"            \n#&gt;  [5] \"Delta Air Lines Inc.\"        \"ExpressJet Airlines Inc.\"   \n#&gt;  [7] \"Frontier Airlines Inc.\"      \"AirTran Airways Corporation\"\n#&gt;  [9] \"Hawaiian Airlines Inc.\"      \"Envoy Air\"                  \n#&gt; [11] \"SkyWest Airlines Inc.\"       \"United Air Lines Inc.\"      \n#&gt; [13] \"US Airways Inc.\"             \"Virgin America\"             \n#&gt; [15] \"Southwest Airlines Co.\"      \"Mesa Airlines Inc.\"",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Le tidyverse</span>"
    ]
  },
  {
    "objectID": "filter.html",
    "href": "filter.html",
    "title": "2  Manipuler les données",
    "section": "",
    "text": "2.1 Préparation\ndplyr fait partie du coeur du tidyverse, elle est donc chargée automatiquement avec :\nlibrary(tidyverse)\nOn peut également la charger individuellement.\nlibrary(dplyr)\nDans ce qui suit on va utiliser le jeu de données nycflights13, contenu dans l’extension du même nom (qu’il faut donc avoir installé). Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de New-York en 2013. Il a la particularité d’être réparti en trois tables :\nOn va charger les trois tables du jeu de données :\nlibrary(nycflights13)\n## Chargement des trois tables\ndata(flights)\ndata(airports)\ndata(airlines)\nTrois objets correspondant aux trois tables ont dû apparaître dans votre environnement.",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#préparation",
    "href": "filter.html#préparation",
    "title": "2  Manipuler les données",
    "section": "",
    "text": "flights contient des informations sur les vols : date, départ, destination, horaires, retard…\nairports contient des informations sur les aéroports\nairlines contient des données sur les compagnies aériennes",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#les-verbes-de-dplyr",
    "href": "filter.html#les-verbes-de-dplyr",
    "title": "2  Manipuler les données",
    "section": "2.2 Les verbes de dplyr",
    "text": "2.2 Les verbes de dplyr\nLa manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données.\n\n2.2.1 slice\nLe verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres.\nSi on souhaite sélectionner la 345e ligne du tableau airports :\n\nslice(airports, 345)\n#&gt; # A tibble: 1 × 8\n#&gt;   faa   name                lat   lon   alt    tz dst   tzone            \n#&gt;   &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\nSi on veut sélectionner les 5 premières lignes :\n\nslice(airports, 1:5)\n#&gt; # A tibble: 5 × 8\n#&gt;   faa   name                            lat   lon   alt    tz dst   tzone       \n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       \n#&gt; 1 04G   Lansdowne Airport              41.1 -80.6  1044    -5 A     America/New…\n#&gt; 2 06A   Moton Field Municipal Airport  32.5 -85.7   264    -6 A     America/Chi…\n#&gt; 3 06C   Schaumburg Regional            42.0 -88.1   801    -6 A     America/Chi…\n#&gt; 4 06N   Randall Airport                41.4 -74.4   523    -5 A     America/New…\n#&gt; 5 09J   Jekyll Island Airport          31.1 -81.4    11    -5 A     America/New…\n\nslice propose plusieurs variantes utiles, dont slice_head et slice_tail, qui permettent de sélectionner les premières ou les dernières lignes du tableau (on peut spécifier le nombre de lignes souhaitées avec n, ou la proportion avec prop).\n\nslice_tail(airports, n = 3)\n#&gt; # A tibble: 3 × 8\n#&gt;   faa   name                        lat   lon   alt    tz dst   tzone           \n#&gt;   &lt;chr&gt; &lt;chr&gt;                     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n#&gt; 1 ZWI   Wilmington Amtrak Station  39.7 -75.6     0    -5 A     America/New_York\n#&gt; 2 ZWU   Washington Union Station   38.9 -77.0    76    -5 A     America/New_York\n#&gt; 3 ZYP   Penn Station               40.8 -74.0    35    -5 A     America/New_York\n\n\nslice_head(airlines, prop = 0.2)\n#&gt; # A tibble: 3 × 2\n#&gt;   carrier name                  \n#&gt;   &lt;chr&gt;   &lt;chr&gt;                 \n#&gt; 1 9E      Endeavor Air Inc.     \n#&gt; 2 AA      American Airlines Inc.\n#&gt; 3 AS      Alaska Airlines Inc.\n\nAutres variantes utiles, slice_min et slice_max permettent de sélectionner les lignes avec les valeurs les plus grandes ou les plus petite d’une variable donnée. Ainsi, la commande suivante sélectionne le vol ayant le retard au départ le plus faible.\n\nslice_min(flights, dep_delay)\n#&gt; # A tibble: 1 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013    12     7     2040           2123       -43       40           2352\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nOn peut aussi spécifier le nombre de lignes souhaitées, par exemple la commande suivante retourne les 5 aéroports avec l’altitude la plus élevée (en cas de valeurs ex-aequo, il se peut que le nombre de lignes retournées soit plus élevé que celui demandé).\n\nslice_max(airports, alt, n = 5)\n#&gt; # A tibble: 5 × 8\n#&gt;   faa   name                              lat   lon   alt    tz dst   tzone     \n#&gt;   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n#&gt; 1 TEX   Telluride                        38.0 -108.  9078    -7 A     America/D…\n#&gt; 2 TVL   Lake Tahoe Airport               38.9 -120.  8544    -8 A     America/L…\n#&gt; 3 ASE   Aspen Pitkin County Sardy Field  39.2 -107.  7820    -7 A     America/D…\n#&gt; 4 GUC   Gunnison - Crested Butte         38.5 -107.  7678    -7 A     America/D…\n#&gt; 5 BCE   Bryce Canyon                     37.7 -112.  7590    -7 A     America/D…\n\n\n\n2.2.2 filter\nfilter sélectionne des lignes d’une table selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie TRUE (vrai) sont conservées. Pour plus d’informations sur les tests et leur syntaxe, voir Chapitre 9.\nPar exemple, si on veut sélectionner les vols du mois de janvier, on peut filtrer sur la variable month de la manière suivante :\n\nfilter(flights, month == 1)\n#&gt; # A tibble: 27,004 × 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     1      533            529         4      850            830\n#&gt;  3  2013     1     1      542            540         2      923            850\n#&gt;  4  2013     1     1      544            545        -1     1004           1022\n#&gt;  5  2013     1     1      554            600        -6      812            837\n#&gt;  6  2013     1     1      554            558        -4      740            728\n#&gt;  7  2013     1     1      555            600        -5      913            854\n#&gt;  8  2013     1     1      557            600        -3      709            723\n#&gt;  9  2013     1     1      557            600        -3      838            846\n#&gt; 10  2013     1     1      558            600        -2      753            745\n#&gt; # ℹ 26,994 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nSi on veut uniquement les vols avec un retard au départ (variable dep_delay) compris entre 10 et 15 minutes :\n\nfilter(flights, dep_delay &gt;= 10 & dep_delay &lt;= 15)\n#&gt; # A tibble: 14,919 × 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      611            600        11      945            931\n#&gt;  2  2013     1     1      623            610        13      920            915\n#&gt;  3  2013     1     1      743            730        13     1107           1100\n#&gt;  4  2013     1     1      743            730        13     1059           1056\n#&gt;  5  2013     1     1      851            840        11     1215           1206\n#&gt;  6  2013     1     1      912            900        12     1241           1220\n#&gt;  7  2013     1     1      914            900        14     1058           1043\n#&gt;  8  2013     1     1      920            905        15     1039           1025\n#&gt;  9  2013     1     1     1011           1001        10     1133           1128\n#&gt; 10  2013     1     1     1112           1100        12     1440           1438\n#&gt; # ℹ 14,909 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nSi on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et entre les conditions. La commande précédente peut donc être écrite de la manière suivante, avec le même résultat :\n\nfilter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15)\n\nOn peut également placer des fonctions dans les tests, qui nous permettent par exemple de sélectionner les vols ayant une distance supérieure à la distance médiane :\n\nfilter(flights, distance &gt; median(distance))\n#&gt; # A tibble: 167,133 × 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     1      533            529         4      850            830\n#&gt;  3  2013     1     1      542            540         2      923            850\n#&gt;  4  2013     1     1      544            545        -1     1004           1022\n#&gt;  5  2013     1     1      555            600        -5      913            854\n#&gt;  6  2013     1     1      557            600        -3      838            846\n#&gt;  7  2013     1     1      558            600        -2      849            851\n#&gt;  8  2013     1     1      558            600        -2      853            856\n#&gt;  9  2013     1     1      558            600        -2      924            917\n#&gt; 10  2013     1     1      558            600        -2      923            937\n#&gt; # ℹ 167,123 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n2.2.3 select et rename\nselect permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes lat et lon du tableau airports :\n\nselect(airports, lat, lon)\n#&gt; # A tibble: 1,458 × 2\n#&gt;      lat    lon\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1  41.1  -80.6\n#&gt;  2  32.5  -85.7\n#&gt;  3  42.0  -88.1\n#&gt;  4  41.4  -74.4\n#&gt;  5  31.1  -81.4\n#&gt;  6  36.4  -82.2\n#&gt;  7  41.5  -84.5\n#&gt;  8  42.9  -76.8\n#&gt;  9  39.8  -76.6\n#&gt; 10  48.1 -123. \n#&gt; # ℹ 1,448 more rows\n\nSi on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée :\n\nselect(airports, -lat, -lon)\n#&gt; # A tibble: 1,458 × 6\n#&gt;    faa   name                             alt    tz dst   tzone              \n#&gt;    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n#&gt;  1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n#&gt;  2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n#&gt;  3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n#&gt;  4 06N   Randall Airport                  523    -5 A     America/New_York   \n#&gt;  5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n#&gt;  6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n#&gt;  7 0G6   Williams County Airport          730    -5 A     America/New_York   \n#&gt;  8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n#&gt;  9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n#&gt; 10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n#&gt; # ℹ 1,448 more rows\n\nselect comprend toute une série de fonctions facilitant la sélection de colonnes multiples. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables.\n\nselect(flights, starts_with(\"dep_\"))\n#&gt; # A tibble: 336,776 × 2\n#&gt;    dep_time dep_delay\n#&gt;       &lt;int&gt;     &lt;dbl&gt;\n#&gt;  1      517         2\n#&gt;  2      533         4\n#&gt;  3      542         2\n#&gt;  4      544        -1\n#&gt;  5      554        -6\n#&gt;  6      554        -4\n#&gt;  7      555        -5\n#&gt;  8      557        -3\n#&gt;  9      557        -3\n#&gt; 10      558        -2\n#&gt; # ℹ 336,766 more rows\n\nLa syntaxe colonne1:colonne2 permet de sélectionner toutes les colonnes situées entre colonne1 et colonne2 incluses1.\n\nselect(flights, year:day)\n#&gt; # A tibble: 336,776 × 3\n#&gt;     year month   day\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;\n#&gt;  1  2013     1     1\n#&gt;  2  2013     1     1\n#&gt;  3  2013     1     1\n#&gt;  4  2013     1     1\n#&gt;  5  2013     1     1\n#&gt;  6  2013     1     1\n#&gt;  7  2013     1     1\n#&gt;  8  2013     1     1\n#&gt;  9  2013     1     1\n#&gt; 10  2013     1     1\n#&gt; # ℹ 336,766 more rows\n\nselect propose de nombreuses autres possibilités de sélection qui sont décrites dans la documentation de l’extension tidyselect.\nUne variante de select est rename2, qui permet de renommer des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nrename(airports, longitude = lon, latitude = lat)\n#&gt; # A tibble: 1,458 × 8\n#&gt;    faa   name                         latitude longitude   alt    tz dst   tzone\n#&gt;    &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt;  1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n#&gt;  2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n#&gt;  3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n#&gt;  4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n#&gt;  5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n#&gt;  6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n#&gt;  7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n#&gt;  8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n#&gt;  9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n#&gt; 10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n#&gt; # ℹ 1,448 more rows\n\nSi les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (\") ou de quotes inverses (`) :\n\ntmp &lt;- rename(\n    flights,\n    \"retard départ\" = dep_delay,\n    \"retard arrivée\" = arr_delay\n)\nselect(tmp, `retard départ`, `retard arrivée`)\n#&gt; # A tibble: 336,776 × 2\n#&gt;    `retard départ` `retard arrivée`\n#&gt;              &lt;dbl&gt;            &lt;dbl&gt;\n#&gt;  1               2               11\n#&gt;  2               4               20\n#&gt;  3               2               33\n#&gt;  4              -1              -18\n#&gt;  5              -6              -25\n#&gt;  6              -4               12\n#&gt;  7              -5               19\n#&gt;  8              -3              -14\n#&gt;  9              -3               -8\n#&gt; 10              -2                8\n#&gt; # ℹ 336,766 more rows\n\n\n\n2.2.4 arrange\narrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nAinsi, si on veut trier le tableau flights selon le retard au départ croissant :\n\narrange(flights, dep_delay)\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013    12     7     2040           2123       -43       40           2352\n#&gt;  2  2013     2     3     2022           2055       -33     2240           2338\n#&gt;  3  2013    11    10     1408           1440       -32     1549           1559\n#&gt;  4  2013     1    11     1900           1930       -30     2233           2243\n#&gt;  5  2013     1    29     1703           1730       -27     1947           1957\n#&gt;  6  2013     8     9      729            755       -26     1002            955\n#&gt;  7  2013    10    23     1907           1932       -25     2143           2143\n#&gt;  8  2013     3    30     2030           2055       -25     2213           2250\n#&gt;  9  2013     3     2     1431           1455       -24     1601           1631\n#&gt; 10  2013     5     5      934            958       -24     1225           1309\n#&gt; # ℹ 336,766 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nOn peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ :\n\narrange(flights, month, dep_delay)\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1    11     1900           1930       -30     2233           2243\n#&gt;  2  2013     1    29     1703           1730       -27     1947           1957\n#&gt;  3  2013     1    12     1354           1416       -22     1606           1650\n#&gt;  4  2013     1    21     2137           2159       -22     2232           2316\n#&gt;  5  2013     1    20      704            725       -21     1025           1035\n#&gt;  6  2013     1    12     2050           2110       -20     2310           2355\n#&gt;  7  2013     1    12     2134           2154       -20        4             50\n#&gt;  8  2013     1    14     2050           2110       -20     2329           2355\n#&gt;  9  2013     1     4     2140           2159       -19     2241           2316\n#&gt; 10  2013     1    11     1947           2005       -18     2209           2230\n#&gt; # ℹ 336,766 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nSi on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() :\n\narrange(flights, desc(dep_delay))\n#&gt; # A tibble: 336,776 × 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     9      641            900      1301     1242           1530\n#&gt;  2  2013     6    15     1432           1935      1137     1607           2120\n#&gt;  3  2013     1    10     1121           1635      1126     1239           1810\n#&gt;  4  2013     9    20     1139           1845      1014     1457           2210\n#&gt;  5  2013     7    22      845           1600      1005     1044           1815\n#&gt;  6  2013     4    10     1100           1900       960     1342           2211\n#&gt;  7  2013     3    17     2321            810       911      135           1020\n#&gt;  8  2013     6    27      959           1900       899     1236           2226\n#&gt;  9  2013     7    22     2257            759       898      121           1026\n#&gt; 10  2013    12     5      756           1700       896     1058           2020\n#&gt; # ℹ 336,766 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\nCombiné avec slice, arrange permet par exemple de sélectionner les trois vols ayant eu le plus de retard :\n\ntmp &lt;- arrange(flights, desc(dep_delay))\nslice(tmp, 1:3)\n#&gt; # A tibble: 3 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     9      641            900      1301     1242           1530\n#&gt; 2  2013     6    15     1432           1935      1137     1607           2120\n#&gt; 3  2013     1    10     1121           1635      1126     1239           1810\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n2.2.5 mutate\nmutate permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table flights contient la durée du vol en minutes.. Si on veut créer une nouvelle variable duree_h avec cette durée en heures, on peut faire :\n\nflights &lt;- mutate(flights, duree_h = air_time / 60)\n\nselect(flights, air_time, duree_h)\n#&gt; # A tibble: 336,776 × 2\n#&gt;    air_time duree_h\n#&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n#&gt;  1      227   3.78 \n#&gt;  2      227   3.78 \n#&gt;  3      160   2.67 \n#&gt;  4      183   3.05 \n#&gt;  5      116   1.93 \n#&gt;  6      150   2.5  \n#&gt;  7      158   2.63 \n#&gt;  8       53   0.883\n#&gt;  9      140   2.33 \n#&gt; 10      138   2.3  \n#&gt; # ℹ 336,766 more rows\n\nOn peut créer plusieurs nouvelles colonnes en une seule commande, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la durée en heures dans une variable duree_h et la distance en kilomètres dans une variable distance_km, puis utilise ces nouvelles colonnes pour calculer la vitesse en km/h.\n\nflights &lt;- mutate(\n    flights,\n    duree_h = air_time / 60,\n    distance_km = distance / 0.62137,\n    vitesse = distance_km / duree_h\n)\n\nselect(flights, air_time, duree_h, distance, distance_km, vitesse)\n#&gt; # A tibble: 336,776 × 5\n#&gt;    air_time duree_h distance distance_km vitesse\n#&gt;       &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;\n#&gt;  1      227   3.78      1400       2253.    596.\n#&gt;  2      227   3.78      1416       2279.    602.\n#&gt;  3      160   2.67      1089       1753.    657.\n#&gt;  4      183   3.05      1576       2536.    832.\n#&gt;  5      116   1.93       762       1226.    634.\n#&gt;  6      150   2.5        719       1157.    463.\n#&gt;  7      158   2.63      1065       1714.    651.\n#&gt;  8       53   0.883      229        369.    417.\n#&gt;  9      140   2.33       944       1519.    651.\n#&gt; 10      138   2.3        733       1180.    513.\n#&gt; # ℹ 336,766 more rows\n\nÀ noter que mutate est évidemment parfaitement compatible avec les fonctions vues ?sec-vectorfactor sur les recodages : fct_recode, ifelse, case_when…\nL’avantage d’utiliser mutate est double. D’abord il permet d’éviter d’avoir à saisir le nom du tableau de données dans les conditions d’un ifelse ou d’un case_when :\n\nflights &lt;- mutate(\n    flights,\n    type_retard = case_when(\n        dep_delay &gt; 0 & arr_delay &gt; 0 ~ \"Retard départ et arrivée\",\n        dep_delay &gt; 0 & arr_delay &lt;= 0 ~ \"Retard départ\",\n        dep_delay &lt;= 0 & arr_delay &gt; 0 ~ \"Retard arrivée\",\n        TRUE ~ \"Aucun retard\"\n    )\n)\n\nEnsuite, il permet aussi d’intégrer ces recodages dans un pipeline de traitement de données, concept présenté dans la section suivante.",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#sec-pipe",
    "href": "filter.html#sec-pipe",
    "title": "2  Manipuler les données",
    "section": "2.3 Enchaîner les opérations avec le pipe",
    "text": "2.3 Enchaîner les opérations avec le pipe\nQuand on manipule un tableau de données, il est très fréquent d’enchaîner plusieurs opérations. On va par exemple extraire une sous-population avec filter, sélectionner des colonnes avec select puis trier selon une variable avec arrange, etc.\nQuand on veut enchaîner des opérations, on peut le faire de différentes manières. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” :\n\narrange(select(filter(flights, dest == \"LAX\"), dep_delay, arr_delay), dep_delay)\n\nCette notation a plusieurs inconvénients :\n\nelle est peu lisible\nles opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier.\nIl est difficile de voir quel paramètre se rapporte à quelle fonction\n\nUne autre manière de faire est d’effectuer les opérations les unes après les autres, en stockant les résultats intermédiaires dans un objet temporaire :\n\ntmp &lt;- filter(flights, dest == \"LAX\")\ntmp &lt;- select(tmp, dep_delay, arr_delay)\narrange(tmp, dep_delay)\n\nC’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire tmp dont on n’a pas réellement besoin.\nPour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe3. Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr).\nAinsi les deux expressions suivantes sont rigoureusement équivalentes :\n\nfilter(flights, dest == \"LAX\")\n\n\nflights %&gt;% filter(dest == \"LAX\")\n\nCe qui est particulièrement intéressant, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire :\n\nselect(filter(flights, dest == \"LAX\"), dep_delay, arr_delay)\n\nOn va pouvoir faire :\n\nflights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay)\n\nÀ chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite : on part de l’objet flights, qu’on passe comme premier argument à la fonction filter, puis on passe le résultat de ce filter comme premier argument du select.\nLe résultat final est le même avec les deux syntaxes, mais avec le pipe l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objet intermédiaire.\nSi la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne :\n\nflights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\n\n\n\n\n\n\nNote\n\n\n\nOn appelle une suite d’instructions de ce type un pipeline.\n\n\nÉvidemment, il est naturel de vouloir récupérer le résultat final d’un pipeline pour le stocker dans un objet. On peut stocker le résultat du pipeline ci-dessus dans un nouveau tableau delay_la de la manière suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay) %&gt;%\n  arrange(dep_delay)\n\nDans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange.\nCette notation n’est pas forcément très intuitive au départ : il faut bien comprendre que c’est le résultat final, une fois application de toutes les opérations du pipeline, qui est renvoyé et stocké dans l’objet en début de ligne.\nUne manière de le comprendre peut être de voir que la notation suivante :\n\ndelay_la &lt;- flights %&gt;%\n  filter(dest == \"LAX\") %&gt;%\n  select(dep_delay, arr_delay)\n\nest équivalente à :\n\ndelay_la &lt;- (flights %&gt;% filter(dest == \"LAX\") %&gt;% select(dep_delay, arr_delay))\n\n\n\n\n\n\n\nNote\n\n\n\nL’utilisation du pipe n’est pas obligatoire, mais elle rend les scripts plus lisibles et plus rapides à saisir. On l’utilisera donc dans ce qui suit.\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nDepuis la version 4.1, R propose un pipe “natif”, qui fonctionne partout, même si on n’utilise pas les extensions du tidyverse. Celui-ci est noté |&gt;.\nIl s’utilise de la même manière que %&gt;% :\nflights |&gt; filter(dest == \"LAX\")\nCe pipe natif est à la fois un peu plus rapide et un peu moins souple. Par exemple, il est possible avec %&gt;% d’appeler une fonction sans mettre de parenthèses :\ndf %&gt;% View\nCe n’est pas possible d’omettre les parenthèses avec |&gt;, on doit obligatoirement faire :\ndf |&gt; View()\nDans la suite de ce document on privilégiera (pour l’instant) le pipe du tidyverse %&gt;%, pour des raisons de compatibilité avec des versions de R moins récentes.",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#opérations-groupées",
    "href": "filter.html#opérations-groupées",
    "title": "2  Manipuler les données",
    "section": "2.4 Opérations groupées",
    "text": "2.4 Opérations groupées\n\n2.4.1 group_by\nUn élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights %&gt;% group_by(month)\n#&gt; # A tibble: 336,776 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     1      533            529         4      850            830\n#&gt;  3  2013     1     1      542            540         2      923            850\n#&gt;  4  2013     1     1      544            545        -1     1004           1022\n#&gt;  5  2013     1     1      554            600        -6      812            837\n#&gt;  6  2013     1     1      554            558        -4      740            728\n#&gt;  7  2013     1     1      555            600        -5      913            854\n#&gt;  8  2013     1     1      557            600        -3      709            723\n#&gt;  9  2013     1     1      557            600        -3      838            846\n#&gt; 10  2013     1     1      558            600        -2      753            745\n#&gt; # ℹ 336,766 more rows\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights %&gt;% group_by(month) %&gt;% slice(1)\n#&gt; # A tibble: 12 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     2     1      456            500        -4      652            648\n#&gt;  3  2013     3     1        4           2159       125      318             56\n#&gt;  4  2013     4     1      454            500        -6      636            640\n#&gt;  5  2013     5     1        9           1655       434      308           2020\n#&gt;  6  2013     6     1        2           2359         3      341            350\n#&gt;  7  2013     7     1        1           2029       212      236           2359\n#&gt;  8  2013     8     1       12           2130       162      257             14\n#&gt;  9  2013     9     1        9           2359        10      343            340\n#&gt; 10  2013    10     1      447            500       -13      614            648\n#&gt; 11  2013    11     1        5           2359         6      352            345\n#&gt; 12  2013    12     1       13           2359        14      446            445\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\nPlus utile, en utilisant une variante comme slice_min ou slice_max, on peut sélectionner les lignes ayant les valeurs les plus grandes ou les plus petites pour chaque groupe. Par exemple la commande suivant sélectionne, pour chaque mois de l’année, le vol ayant eu le retard le plus important.\n\nflights %&gt;% group_by(month) %&gt;% slice_max(dep_delay)\n#&gt; # A tibble: 12 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     9      641            900      1301     1242           1530\n#&gt;  2  2013     2    10     2243            830       853      100           1106\n#&gt;  3  2013     3    17     2321            810       911      135           1020\n#&gt;  4  2013     4    10     1100           1900       960     1342           2211\n#&gt;  5  2013     5     3     1133           2055       878     1250           2215\n#&gt;  6  2013     6    15     1432           1935      1137     1607           2120\n#&gt;  7  2013     7    22      845           1600      1005     1044           1815\n#&gt;  8  2013     8     8     2334           1454       520      120           1710\n#&gt;  9  2013     9    20     1139           1845      1014     1457           2210\n#&gt; 10  2013    10    14     2042            900       702     2255           1127\n#&gt; 11  2013    11     3      603           1645       798      829           1913\n#&gt; 12  2013    12     5      756           1700       896     1058           2020\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\nIdem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquées groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen pour chaque compagnie aérienne. Cette valeur est donc différente d’une compagnie à une autre, mais identique pour tous les vols d’une même compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(mean_delay_carrier = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  select(dep_delay, mean_delay_carrier)\n#&gt; Adding missing grouping variables: `carrier`\n#&gt; # A tibble: 336,776 × 3\n#&gt; # Groups:   carrier [16]\n#&gt;    carrier dep_delay mean_delay_carrier\n#&gt;    &lt;chr&gt;       &lt;dbl&gt;              &lt;dbl&gt;\n#&gt;  1 UA              2              12.1 \n#&gt;  2 UA              4              12.1 \n#&gt;  3 AA              2               8.59\n#&gt;  4 B6             -1              13.0 \n#&gt;  5 DL             -6               9.26\n#&gt;  6 UA             -4              12.1 \n#&gt;  7 B6             -5              13.0 \n#&gt;  8 EV             -3              20.0 \n#&gt;  9 B6             -3              13.0 \n#&gt; 10 AA             -2               8.59\n#&gt; # ℹ 336,766 more rows\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard médian de la compagnie :\n\nflights %&gt;%\n  group_by(carrier) %&gt;%\n  mutate(\n      median_delay = median(dep_delay, na.rm = TRUE),\n      delay_carrier = ifelse(\n          dep_delay &gt; median_delay,\n          \"Supérieur\",\n          \"Inférieur ou égal\"\n      )\n  ) %&gt;%\n  select(dep_delay, median_delay, delay_carrier)\n#&gt; Adding missing grouping variables: `carrier`\n#&gt; # A tibble: 336,776 × 4\n#&gt; # Groups:   carrier [16]\n#&gt;    carrier dep_delay median_delay delay_carrier    \n#&gt;    &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;            \n#&gt;  1 UA              2            0 Supérieur        \n#&gt;  2 UA              4            0 Supérieur        \n#&gt;  3 AA              2           -3 Supérieur        \n#&gt;  4 B6             -1           -1 Inférieur ou égal\n#&gt;  5 DL             -6           -2 Inférieur ou égal\n#&gt;  6 UA             -4            0 Inférieur ou égal\n#&gt;  7 B6             -5           -1 Inférieur ou égal\n#&gt;  8 EV             -3           -1 Inférieur ou égal\n#&gt;  9 B6             -3           -1 Inférieur ou égal\n#&gt; 10 AA             -2           -3 Supérieur        \n#&gt; # ℹ 336,766 more rows\n\ngroup_by peut aussi être utile avec filter, par exemple pour sélectionner pour chaque mois les vols avec un retard au départ plus élevé que le retard moyen ce mois-ci.\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  filter(dep_delay &gt;= mean(dep_delay, na.rm = TRUE))\n#&gt; # A tibble: 78,164 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      611            600        11      945            931\n#&gt;  2  2013     1     1      623            610        13      920            915\n#&gt;  3  2013     1     1      632            608        24      740            728\n#&gt;  4  2013     1     1      732            645        47     1011            941\n#&gt;  5  2013     1     1      743            730        13     1107           1100\n#&gt;  6  2013     1     1      743            730        13     1059           1056\n#&gt;  7  2013     1     1      749            710        39      939            850\n#&gt;  8  2013     1     1      811            630       101     1047            830\n#&gt;  9  2013     1     1      826            715        71     1136           1045\n#&gt; 10  2013     1     1      848           1835       853     1001           1950\n#&gt; # ℹ 78,154 more rows\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n\n\n\n\nAvertissement\n\n\n\nAttention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\n\n\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay))\n#&gt; # A tibble: 336,776 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     9      641            900      1301     1242           1530\n#&gt;  2  2013     6    15     1432           1935      1137     1607           2120\n#&gt;  3  2013     1    10     1121           1635      1126     1239           1810\n#&gt;  4  2013     9    20     1139           1845      1014     1457           2210\n#&gt;  5  2013     7    22      845           1600      1005     1044           1815\n#&gt;  6  2013     4    10     1100           1900       960     1342           2211\n#&gt;  7  2013     3    17     2321            810       911      135           1020\n#&gt;  8  2013     6    27      959           1900       899     1236           2226\n#&gt;  9  2013     7    22     2257            759       898      121           1026\n#&gt; 10  2013    12     5      756           1700       896     1058           2020\n#&gt; # ℹ 336,766 more rows\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  arrange(desc(dep_delay), .by_group = TRUE)\n#&gt; # A tibble: 336,776 × 22\n#&gt; # Groups:   month [12]\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     9      641            900      1301     1242           1530\n#&gt;  2  2013     1    10     1121           1635      1126     1239           1810\n#&gt;  3  2013     1     1      848           1835       853     1001           1950\n#&gt;  4  2013     1    13     1809            810       599     2054           1042\n#&gt;  5  2013     1    16     1622            800       502     1911           1054\n#&gt;  6  2013     1    23     1551            753       478     1812           1006\n#&gt;  7  2013     1    10     1525            900       385     1713           1039\n#&gt;  8  2013     1     1     2343           1724       379      314           1938\n#&gt;  9  2013     1     2     2131           1512       379     2340           1741\n#&gt; 10  2013     1     7     2021           1415       366     2332           1724\n#&gt; # ℹ 336,766 more rows\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\n\n\n2.4.2 summarise et count\nsummarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights %&gt;%\n  summarise(\n      retard_dep = mean(dep_delay, na.rm = TRUE),\n      retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 1 × 2\n#&gt;   retard_dep retard_arr\n#&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1       12.6       6.90\n\nCette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights %&gt;%\n  group_by(month) %&gt;%\n  summarise(\n      max_delay = max(dep_delay, na.rm = TRUE),\n      min_delay = min(dep_delay, na.rm = TRUE),\n      mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n#&gt; # A tibble: 12 × 4\n#&gt;    month max_delay min_delay mean_delay\n#&gt;    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1     1      1301       -30      10.0 \n#&gt;  2     2       853       -33      10.8 \n#&gt;  3     3       911       -25      13.2 \n#&gt;  4     4       960       -21      13.9 \n#&gt;  5     5       878       -24      13.0 \n#&gt;  6     6      1137       -21      20.8 \n#&gt;  7     7      1005       -22      21.7 \n#&gt;  8     8       520       -26      12.6 \n#&gt;  9     9      1014       -24       6.72\n#&gt; 10    10       702       -25       6.24\n#&gt; 11    11       798       -32       5.44\n#&gt; 12    12       896       -43      16.6\n\nsummarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination, on peut utiliser :\n\nflights %&gt;%\n  group_by(dest) %&gt;%\n  summarise(nb = n())\n#&gt; # A tibble: 105 × 2\n#&gt;    dest     nb\n#&gt;    &lt;chr&gt; &lt;int&gt;\n#&gt;  1 ABQ     254\n#&gt;  2 ACK     265\n#&gt;  3 ALB     439\n#&gt;  4 ANC       8\n#&gt;  5 ATL   17215\n#&gt;  6 AUS    2439\n#&gt;  7 AVL     275\n#&gt;  8 BDL     443\n#&gt;  9 BGR     375\n#&gt; 10 BHM     297\n#&gt; # ℹ 95 more rows\n\nn() peut aussi être utilisée avec filter et mutate.\nÀ noter que quand on veut compter le nombre de lignes par groupe, il est plus simple d’utiliser directement la fonction count. Ainsi le code suivant est identique au précédent :\n\nflights %&gt;%\n  count(dest)\n#&gt; # A tibble: 105 × 2\n#&gt;    dest      n\n#&gt;    &lt;chr&gt; &lt;int&gt;\n#&gt;  1 ABQ     254\n#&gt;  2 ACK     265\n#&gt;  3 ALB     439\n#&gt;  4 ANC       8\n#&gt;  5 ATL   17215\n#&gt;  6 AUS    2439\n#&gt;  7 AVL     275\n#&gt;  8 BDL     443\n#&gt;  9 BGR     375\n#&gt; 10 BHM     297\n#&gt; # ℹ 95 more rows\n\n\n\n2.4.3 Grouper selon plusieurs variables\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by. Le pipeline suivant calcule le retard moyen au départ pour chaque mois et pour chaque destination, et trie le résultat par retard décroissant :\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  arrange(desc(retard_moyen))\n#&gt; `summarise()` has grouped output by 'month'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 1,113 × 3\n#&gt; # Groups:   month [12]\n#&gt;    month dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1    12 BZN           75  \n#&gt;  2     7 TUL           72.6\n#&gt;  3     3 DSM           71.0\n#&gt;  4     7 CAE           69.4\n#&gt;  5    11 SBN           67.5\n#&gt;  6     7 BHM           64.6\n#&gt;  7     7 TYS           60.6\n#&gt;  8     6 BHM           57.2\n#&gt;  9     1 TUL           55.2\n#&gt; 10     1 SAV           54.8\n#&gt; # ℹ 1,103 more rows\n\nOn peut également utiliser count sur plusieurs variables. Les commandes suivantes comptent le nombre de vols pour chaque couple aéroport de départ / aéroport d’arrivée, et trie le résultat par nombre de vols décroissant. Ici la colonne qui contient le nombre de vols, créée par count, s’appelle n par défaut :\n\nflights %&gt;%\n  count(origin, dest) %&gt;%\n  arrange(desc(n))\n#&gt; # A tibble: 224 × 3\n#&gt;    origin dest      n\n#&gt;    &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n#&gt;  1 JFK    LAX   11262\n#&gt;  2 LGA    ATL   10263\n#&gt;  3 LGA    ORD    8857\n#&gt;  4 JFK    SFO    8204\n#&gt;  5 LGA    CLT    6168\n#&gt;  6 EWR    ORD    6100\n#&gt;  7 JFK    BOS    5898\n#&gt;  8 LGA    MIA    5781\n#&gt;  9 JFK    MCO    5464\n#&gt; 10 EWR    BOS    5327\n#&gt; # ℹ 214 more rows\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si on souhaite déterminer le couple aéroport de départ / aéroport d’arrivée ayant le retard moyen au départ le plus élevé pour chaque mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, aéroports d’origine et d’arrivée pour calculer le retard moyen\npuis grouper uniquement selon le mois pour sélectionner le mois avec le retard moyen maximal.\n\nAu final, on obtient le code suivant :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  group_by(month) %&gt;%\n  slice_max(retard_moyen)\n#&gt; `summarise()` has grouped output by 'month', 'origin'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 12 × 4\n#&gt; # Groups:   month [12]\n#&gt;    month origin dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1     1 EWR    TUL           55.2\n#&gt;  2     2 EWR    DSM           48.6\n#&gt;  3     3 EWR    DSM           71.0\n#&gt;  4     4 EWR    OKC           47.0\n#&gt;  5     5 EWR    TYS           60.6\n#&gt;  6     6 EWR    TYS           68.2\n#&gt;  7     7 EWR    CAE           81.5\n#&gt;  8     8 LGA    GSO           50.1\n#&gt;  9     9 LGA    MSN           24.7\n#&gt; 10    10 EWR    CAE           50.1\n#&gt; 11    11 LGA    SBN           67.5\n#&gt; 12    12 EWR    BZN           75\n\n\n\n2.4.4 Dégroupage\nLorsqu’on effectue un group_by suivi d’un summarise, le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est seulement groupé par month et origin :\n\nflights %&gt;%\n  group_by(month, origin, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE))\n#&gt; `summarise()` has grouped output by 'month', 'origin'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 2,313 × 4\n#&gt; # Groups:   month, origin [36]\n#&gt;    month origin dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1     1 EWR    ALB          41.4 \n#&gt;  2     1 EWR    ATL           8.07\n#&gt;  3     1 EWR    AUS           6.67\n#&gt;  4     1 EWR    AVL          25.5 \n#&gt;  5     1 EWR    BDL          21.1 \n#&gt;  6     1 EWR    BNA          16.3 \n#&gt;  7     1 EWR    BOS           8.99\n#&gt;  8     1 EWR    BQN          12.3 \n#&gt;  9     1 EWR    BTV          20.5 \n#&gt; 10     1 EWR    BUF          23.1 \n#&gt; # ℹ 2,303 more rows\n\ndplyr nous le signale d’ailleurs via un message d’avertissement : summarise() has grouped output by 'month', 'origin'.\nCe dégroupage progressif peut permettre “d’enchaîner” les opérations groupées. Dans l’exemple suivant on calcule le retard moyen au départ par destination et on conserve les trois retards les plus importants pour chaque mois.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  slice_max(retard_moyen, n = 3)\n#&gt; `summarise()` has grouped output by 'month'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 36 × 3\n#&gt; # Groups:   month [12]\n#&gt;    month dest  retard_moyen\n#&gt;    &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1     1 TUL           55.2\n#&gt;  2     1 SAV           54.8\n#&gt;  3     1 DSM           42.2\n#&gt;  4     2 DSM           48.6\n#&gt;  5     2 TUL           34.2\n#&gt;  6     2 GSP           32.4\n#&gt;  7     3 DSM           71.0\n#&gt;  8     3 PVD           47.5\n#&gt;  9     3 CAE           46.9\n#&gt; 10     4 OKC           47.0\n#&gt; # ℹ 26 more rows\n\nOn peut à tout moment “dégrouper” un tableau à l’aide de ungroup. C’est nécessaire, dans l’exemple précédent, si on veut seulement récupérer les trois retards les plus importants pour l’ensemble des couples mois / destination.\n\nflights %&gt;%\n  group_by(month, dest) %&gt;%\n  summarise(retard_moyen = mean(dep_delay, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  slice_max(retard_moyen, n = 3)\n#&gt; `summarise()` has grouped output by 'month'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 3 × 3\n#&gt;   month dest  retard_moyen\n#&gt;   &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt; 1    12 BZN           75  \n#&gt; 2     7 TUL           72.6\n#&gt; 3     3 DSM           71.0\n\nOn peut aussi spécifier précisément le comportement de dégroupage de summarise en lui fournissant un argument supplémentaire .groups qui peut prendre notamment les valeurs suivantes :\n\n\"drop_last\" : dégroupe seulement de la dernière variable de groupage\n\"drop\" : dégroupe totalement le tableau résultat (équivaut à l’application d’un ungroup)\n\"keep\" : conserve toutes les variables de groupage\n\nCe concept de dégroupage successif peut être un peu déroutant de prime abord. Il est donc utile de faire attention aux avertissements affichés par ces opérations, et il ne faut pas hésiter à ajouter un ungroup en fin de pipeline si on sait qu’on ne souhaite pas utiliser les groupes encore existants par la suite.\nÀ noter que la fonction count, de son côté, renvoie un tableau non groupé.\n\nflights %&gt;%\n  count(month, dest)\n#&gt; # A tibble: 1,113 × 3\n#&gt;    month dest      n\n#&gt;    &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n#&gt;  1     1 ALB      64\n#&gt;  2     1 ATL    1396\n#&gt;  3     1 AUS     169\n#&gt;  4     1 AVL       2\n#&gt;  5     1 BDL      37\n#&gt;  6     1 BHM      25\n#&gt;  7     1 BNA     399\n#&gt;  8     1 BOS    1245\n#&gt;  9     1 BQN      93\n#&gt; 10     1 BTV     223\n#&gt; # ℹ 1,103 more rows",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#autres-fonctions-utiles",
    "href": "filter.html#autres-fonctions-utiles",
    "title": "2  Manipuler les données",
    "section": "2.5 Autres fonctions utiles",
    "text": "2.5 Autres fonctions utiles\ndplyr contient beaucoup d’autres fonctions utiles pour la manipulation de données.\n\n2.5.1 slice_sample\nCe verbe permet de sélectionner aléatoirement un nombre de lignes (avec l’argument n) ou une fraction des lignes (avec l’argument prop) d’un tableau.\nAinsi si on veut choisir 5 lignes au hasard dans le tableau airports :\n\nairports %&gt;% slice_sample(n = 5)\n#&gt; # A tibble: 5 × 8\n#&gt;   faa   name                             lat    lon   alt    tz dst   tzone     \n#&gt;   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n#&gt; 1 CRW   Yeager                          38.4  -81.6   981    -5 A     America/N…\n#&gt; 2 GLV   Golovin Airport                 64.6 -163.     59    -9 A     America/A…\n#&gt; 3 LFT   Lafayette Rgnl                  30.2  -92.0    43    -6 A     America/C…\n#&gt; 4 MTM   Metlakatla Seaplane Base        55.1 -132.      0    -9 A     America/A…\n#&gt; 5 POF   Poplar Bluff Municipal Airport  36.8  -90.3   331    -6 A     America/C…\n\nSi on veut tirer au hasard 10% des lignes de flights :\n\nflights %&gt;% slice_sample(prop = 0.1)\n#&gt; # A tibble: 33,677 × 22\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013    12    13     1829           1840       -11     2010           2025\n#&gt;  2  2013     1    23     2254           1940       194       10           2100\n#&gt;  3  2013     7    10       NA           1510        NA       NA           1734\n#&gt;  4  2013     1     1     1439           1445        -6     1558           1613\n#&gt;  5  2013     3     6       NA           2000        NA       NA           2243\n#&gt;  6  2013     6    12     1413           1415        -2     1626           1655\n#&gt;  7  2013     1    10     1941           1940         1     2231           2249\n#&gt;  8  2013     2    16     1354           1330        24     1626           1645\n#&gt;  9  2013     3    15     1351           1124       147     1442           1224\n#&gt; 10  2013     7    10     2305           2055       130      113           2324\n#&gt; # ℹ 33,667 more rows\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\nCes fonctions sont utiles notamment pour faire de “l’échantillonnage” en tirant au hasard un certain nombre d’observations du tableau.\n\n\n2.5.2 lead et lag\nlead et lag permettent de décaler les observations d’une variable d’un cran vers l’arrière (pour lead) ou vers l’avant (pour lag).\n\nlead(1:5)\n#&gt; [1]  2  3  4  5 NA\nlag(1:5)\n#&gt; [1] NA  1  2  3  4\n\nCeci peut être utile pour des données de type “séries temporelles”. Par exemple, on peut facilement calculer l’écart entre le retard au départ de chaque vol et celui du vol précédent :\n\nflights %&gt;%\n  mutate(\n      dep_delay_prev = lag(dep_delay),\n      dep_delay_diff = dep_delay - dep_delay_prev\n  ) %&gt;%\n  select(dep_delay_prev, dep_delay, dep_delay_diff)\n#&gt; # A tibble: 336,776 × 3\n#&gt;    dep_delay_prev dep_delay dep_delay_diff\n#&gt;             &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;\n#&gt;  1             NA         2             NA\n#&gt;  2              2         4              2\n#&gt;  3              4         2             -2\n#&gt;  4              2        -1             -3\n#&gt;  5             -1        -6             -5\n#&gt;  6             -6        -4              2\n#&gt;  7             -4        -5             -1\n#&gt;  8             -5        -3              2\n#&gt;  9             -3        -3              0\n#&gt; 10             -3        -2              1\n#&gt; # ℹ 336,766 more rows\n\n\n\n2.5.3 distinct et n_distinct\ndistinct filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double.\n\nflights %&gt;%\n  select(day, month) %&gt;%\n  distinct()\n#&gt; # A tibble: 365 × 2\n#&gt;      day month\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt;  1     1     1\n#&gt;  2     2     1\n#&gt;  3     3     1\n#&gt;  4     4     1\n#&gt;  5     5     1\n#&gt;  6     6     1\n#&gt;  7     7     1\n#&gt;  8     8     1\n#&gt;  9     9     1\n#&gt; 10    10     1\n#&gt; # ℹ 355 more rows\n\nOn peut lui spécifier une liste de variables : dans ce cas, pour toutes les observations ayant des valeurs identiques pour les variables en question, distinct ne conservera que la première d’entre elles.\n\nflights %&gt;%\n  distinct(month, day)\n#&gt; # A tibble: 365 × 2\n#&gt;    month   day\n#&gt;    &lt;int&gt; &lt;int&gt;\n#&gt;  1     1     1\n#&gt;  2     1     2\n#&gt;  3     1     3\n#&gt;  4     1     4\n#&gt;  5     1     5\n#&gt;  6     1     6\n#&gt;  7     1     7\n#&gt;  8     1     8\n#&gt;  9     1     9\n#&gt; 10     1    10\n#&gt; # ℹ 355 more rows\n\nL’option .keep_all permet, dans l’opération précédente, de conserver l’ensemble des colonnes du tableau :\n\nflights %&gt;%\n  distinct(month, day, .keep_all = TRUE)\n#&gt; # A tibble: 365 × 22\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     2       42           2359        43      518            442\n#&gt;  3  2013     1     3       32           2359        33      504            442\n#&gt;  4  2013     1     4       25           2359        26      505            442\n#&gt;  5  2013     1     5       14           2359        15      503            445\n#&gt;  6  2013     1     6       16           2359        17      451            442\n#&gt;  7  2013     1     7       49           2359        50      531            444\n#&gt;  8  2013     1     8      454            500        -6      625            648\n#&gt;  9  2013     1     9        2           2359         3      432            444\n#&gt; 10  2013     1    10        3           2359         4      426            437\n#&gt; # ℹ 355 more rows\n#&gt; # ℹ 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, duree_h &lt;dbl&gt;,\n#&gt; #   distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;\n\nLa fonction n_distinct, elle, renvoie le nombre de valeurs distinctes d’un vecteur. On peut notamment l’utiliser dans un summarise.\nDans l’exemple qui suit on calcule, pour les trois aéroports de départ de la table flights le nombre de valeurs distinctes de l’aéroport d’arrivée :\n\nflights %&gt;%\n  group_by(origin) %&gt;%\n  summarise(n_dest = n_distinct(dest))\n#&gt; # A tibble: 3 × 2\n#&gt;   origin n_dest\n#&gt;   &lt;chr&gt;   &lt;int&gt;\n#&gt; 1 EWR        86\n#&gt; 2 JFK        70\n#&gt; 3 LGA        68\n\n\n\n2.5.4 relocate\nrelocate peut être utilisé pour réordonner les colonnes d’une table. Par défaut, si on lui passe un ou plusieurs noms de colonnes, relocate les place en début de tableau.\n\nairports %&gt;% relocate(lat, lon)\n#&gt; # A tibble: 1,458 × 8\n#&gt;      lat    lon faa   name                             alt    tz dst   tzone    \n#&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n#&gt;  1  41.1  -80.6 04G   Lansdowne Airport               1044    -5 A     America/…\n#&gt;  2  32.5  -85.7 06A   Moton Field Municipal Airport    264    -6 A     America/…\n#&gt;  3  42.0  -88.1 06C   Schaumburg Regional              801    -6 A     America/…\n#&gt;  4  41.4  -74.4 06N   Randall Airport                  523    -5 A     America/…\n#&gt;  5  31.1  -81.4 09J   Jekyll Island Airport             11    -5 A     America/…\n#&gt;  6  36.4  -82.2 0A9   Elizabethton Municipal Airport  1593    -5 A     America/…\n#&gt;  7  41.5  -84.5 0G6   Williams County Airport          730    -5 A     America/…\n#&gt;  8  42.9  -76.8 0G7   Finger Lakes Regional Airport    492    -5 A     America/…\n#&gt;  9  39.8  -76.6 0P2   Shoestring Aviation Airfield    1000    -5 U     America/…\n#&gt; 10  48.1 -123.  0S9   Jefferson County Intl            108    -8 A     America/…\n#&gt; # ℹ 1,448 more rows\n\nLes arguments supplémentaires .before et .after permettent de préciser à quel endroit déplacer la ou les colonnes indiquées.\n\nairports %&gt;% relocate(starts_with('tz'), .after = name)\n#&gt; # A tibble: 1,458 × 8\n#&gt;    faa   name                              tz tzone       lat    lon   alt dst  \n#&gt;    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt;  1 04G   Lansdowne Airport                 -5 America/…  41.1  -80.6  1044 A    \n#&gt;  2 06A   Moton Field Municipal Airport     -6 America/…  32.5  -85.7   264 A    \n#&gt;  3 06C   Schaumburg Regional               -6 America/…  42.0  -88.1   801 A    \n#&gt;  4 06N   Randall Airport                   -5 America/…  41.4  -74.4   523 A    \n#&gt;  5 09J   Jekyll Island Airport             -5 America/…  31.1  -81.4    11 A    \n#&gt;  6 0A9   Elizabethton Municipal Airport    -5 America/…  36.4  -82.2  1593 A    \n#&gt;  7 0G6   Williams County Airport           -5 America/…  41.5  -84.5   730 A    \n#&gt;  8 0G7   Finger Lakes Regional Airport     -5 America/…  42.9  -76.8   492 A    \n#&gt;  9 0P2   Shoestring Aviation Airfield      -5 America/…  39.8  -76.6  1000 U    \n#&gt; 10 0S9   Jefferson County Intl             -8 America/…  48.1 -123.    108 A    \n#&gt; # ℹ 1,448 more rows",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#tables-multiples",
    "href": "filter.html#tables-multiples",
    "title": "2  Manipuler les données",
    "section": "2.6 Tables multiples",
    "text": "2.6 Tables multiples\nLe jeu de données nycflights13 est un exemple de données réparties en plusieurs tables. Ici on en a trois : les informations sur les vols dans flights, celles sur les aéroports dans airports et celles sur les compagnies aériennes dans airlines.\ndplyr propose différentes fonctions permettant de travailler avec des données structurées de cette manière.\n\n2.6.1 Concaténation : bind_rows et bind_cols\nLes fonctions bind_rows et bind_cols permettent d’ajouter des lignes (respectivement des colonnes) à une table à partir d’une ou plusieurs autres tables.\nL’exemple suivant (certes très artificiel) montre l’utilisation de bind_rows. On commence par créer trois tableaux t1, t2 et t3 :\n\nt1 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(1:2)\nt1\n#&gt; # A tibble: 2 × 4\n#&gt;   faa   name                            lat   lon\n#&gt;   &lt;chr&gt; &lt;chr&gt;                         &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 04G   Lansdowne Airport              41.1 -80.6\n#&gt; 2 06A   Moton Field Municipal Airport  32.5 -85.7\n\n\nt2 &lt;- airports %&gt;%\n  select(faa, name, lat, lon) %&gt;%\n  slice(5:6)\n\nt2\n#&gt; # A tibble: 2 × 4\n#&gt;   faa   name                             lat   lon\n#&gt;   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n\n\nt3 &lt;- airports %&gt;%\n  select(faa, name) %&gt;%\n  slice(100:101)\nt3\n#&gt; # A tibble: 2 × 2\n#&gt;   faa   name             \n#&gt;   &lt;chr&gt; &lt;chr&gt;            \n#&gt; 1 ADW   Andrews Afb      \n#&gt; 2 AET   Allakaket Airport\n\nOn concaténe ensuite les trois tables avec bind_rows :\n\nbind_rows(t1, t2, t3)\n#&gt; # A tibble: 6 × 4\n#&gt;   faa   name                             lat   lon\n#&gt;   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 04G   Lansdowne Airport               41.1 -80.6\n#&gt; 2 06A   Moton Field Municipal Airport   32.5 -85.7\n#&gt; 3 09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 4 0A9   Elizabethton Municipal Airport  36.4 -82.2\n#&gt; 5 ADW   Andrews Afb                     NA    NA  \n#&gt; 6 AET   Allakaket Airport               NA    NA\n\nOn remarquera que si des colonnes sont manquantes pour certaines tables, comme les colonnes lat et lon de t3, des NA sont automatiquement insérées.\nIl peut être utile, quand on concatène des lignes, de garder une trace du tableau d’origine de chacune des lignes dans le tableau final. C’est possible grâce à l’argument .id de bind_rows. On passe à cet argument le nom d’une colonne qui contiendra l’indicateur d’origine des lignes :\n\nbind_rows(t1, t2, t3, .id = \"source\")\n#&gt; # A tibble: 6 × 5\n#&gt;   source faa   name                             lat   lon\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 1      04G   Lansdowne Airport               41.1 -80.6\n#&gt; 2 1      06A   Moton Field Municipal Airport   32.5 -85.7\n#&gt; 3 2      09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 4 2      0A9   Elizabethton Municipal Airport  36.4 -82.2\n#&gt; 5 3      ADW   Andrews Afb                     NA    NA  \n#&gt; 6 3      AET   Allakaket Airport               NA    NA\n\nPar défaut la colonne .id ne contient qu’un nombre, différent pour chaque tableau. On peut lui spécifier des valeurs plus explicites en “nommant” les tables dans bind_rows de la manière suivante :\n\nbind_rows(table1 = t1, table2 = t2, table3 = t3, .id = \"source\")\n#&gt; # A tibble: 6 × 5\n#&gt;   source faa   name                             lat   lon\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 table1 04G   Lansdowne Airport               41.1 -80.6\n#&gt; 2 table1 06A   Moton Field Municipal Airport   32.5 -85.7\n#&gt; 3 table2 09J   Jekyll Island Airport           31.1 -81.4\n#&gt; 4 table2 0A9   Elizabethton Municipal Airport  36.4 -82.2\n#&gt; 5 table3 ADW   Andrews Afb                     NA    NA  \n#&gt; 6 table3 AET   Allakaket Airport               NA    NA\n\nbind_cols permet de concaténer des colonnes et fonctionne de manière similaire :\n\nt1 &lt;- flights %&gt;% slice(1:5) %&gt;% select(dep_delay, dep_time)\nt2 &lt;- flights %&gt;% slice(1:5) %&gt;% select(origin, dest)\nt3 &lt;- flights %&gt;% slice(1:5) %&gt;% select(arr_delay, arr_time)\nbind_cols(t1, t2, t3)\n#&gt; # A tibble: 5 × 6\n#&gt;   dep_delay dep_time origin dest  arr_delay arr_time\n#&gt;       &lt;dbl&gt;    &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1         2      517 EWR    IAH          11      830\n#&gt; 2         4      533 LGA    IAH          20      850\n#&gt; 3         2      542 JFK    MIA          33      923\n#&gt; 4        -1      544 JFK    BQN         -18     1004\n#&gt; 5        -6      554 LGA    ATL         -25      812\n\nÀ noter que bind_cols associe les lignes uniquement par position. Les lignes des différents tableaux associés doivent donc correspondre (et leur nombre doit être identique). Pour associer des tables par valeur, on doit utiliser des jointures.\n\n\n2.6.2 Jointures\n\n2.6.2.1 Clés implicites\nTrès souvent, les données relatives à une analyse sont réparties dans plusieurs tables différentes. Dans notre exemple, on peut voir que la table flights contient le code de la compagnie aérienne du vol dans la variable carrier :\n\nflights %&gt;% select(carrier)\n#&gt; # A tibble: 336,776 × 1\n#&gt;    carrier\n#&gt;    &lt;chr&gt;  \n#&gt;  1 UA     \n#&gt;  2 UA     \n#&gt;  3 AA     \n#&gt;  4 B6     \n#&gt;  5 DL     \n#&gt;  6 UA     \n#&gt;  7 B6     \n#&gt;  8 EV     \n#&gt;  9 B6     \n#&gt; 10 AA     \n#&gt; # ℹ 336,766 more rows\n\nEt que par ailleurs la table airlines contient une information supplémentaire relative à ces compagnies, à savoir le nom complet.\n\nairlines\n#&gt; # A tibble: 16 × 2\n#&gt;    carrier name                       \n#&gt;    &lt;chr&gt;   &lt;chr&gt;                      \n#&gt;  1 9E      Endeavor Air Inc.          \n#&gt;  2 AA      American Airlines Inc.     \n#&gt;  3 AS      Alaska Airlines Inc.       \n#&gt;  4 B6      JetBlue Airways            \n#&gt;  5 DL      Delta Air Lines Inc.       \n#&gt;  6 EV      ExpressJet Airlines Inc.   \n#&gt;  7 F9      Frontier Airlines Inc.     \n#&gt;  8 FL      AirTran Airways Corporation\n#&gt;  9 HA      Hawaiian Airlines Inc.     \n#&gt; 10 MQ      Envoy Air                  \n#&gt; 11 OO      SkyWest Airlines Inc.      \n#&gt; 12 UA      United Air Lines Inc.      \n#&gt; 13 US      US Airways Inc.            \n#&gt; 14 VX      Virgin America             \n#&gt; 15 WN      Southwest Airlines Co.     \n#&gt; 16 YV      Mesa Airlines Inc.\n\nIl est donc naturel de vouloir associer les deux, ici pour ajouter les noms complets des compagnies à la table flights. Pour cela on va effectuer une jointure : les lignes d’une table seront associées à une autre en se basant non pas sur leur position, mais sur les valeurs d’une ou plusieurs colonnes. Ces colonnes sont appelées des clés.\nPour faire une jointure de ce type, on va utiliser la fonction left_join :\n\nleft_join(flights, airlines)\n\nPour faciliter la lecture, on va afficher seulement certaines colonnes du résultat :\n\nleft_join(flights, airlines) %&gt;%\n  select(month, day, carrier, name)\n#&gt; Joining with `by = join_by(carrier)`\n#&gt; # A tibble: 336,776 × 4\n#&gt;    month   day carrier name                    \n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;                   \n#&gt;  1     1     1 UA      United Air Lines Inc.   \n#&gt;  2     1     1 UA      United Air Lines Inc.   \n#&gt;  3     1     1 AA      American Airlines Inc.  \n#&gt;  4     1     1 B6      JetBlue Airways         \n#&gt;  5     1     1 DL      Delta Air Lines Inc.    \n#&gt;  6     1     1 UA      United Air Lines Inc.   \n#&gt;  7     1     1 B6      JetBlue Airways         \n#&gt;  8     1     1 EV      ExpressJet Airlines Inc.\n#&gt;  9     1     1 B6      JetBlue Airways         \n#&gt; 10     1     1 AA      American Airlines Inc.  \n#&gt; # ℹ 336,766 more rows\n\nOn voit que la table résultat est bien la fusion des deux tables d’origine selon les valeurs des deux colonnes clés carrier. On est parti de la table flights, et pour chaque ligne de celle-ci on a ajouté les colonnes de airlines pour lesquelles la valeur de carrier est la même. On a donc bien une nouvelle colonne name dans notre table résultat, avec le nom complet de la compagnie aérienne.\n\n\n\n\n\n\nNote\n\n\n\nÀ noter qu’on peut tout à fait utiliser le pipe avec les fonctions de jointure :\nflights %&gt;% left_join(airlines).\n\n\nNous sommes ici dans le cas le plus simple concernant les clés de jointure : les deux clés sont uniques et portent le même nom dans les deux tables. Par défaut, si on ne lui spécifie pas explicitement les clés, dplyr fusionne en utilisant l’ensemble des colonnes communes aux deux tables. On peut d’ailleurs voir dans cet exemple qu’un message a été affiché précisant que la jointure s’est bien faite sur la variable carrier.\n\n\n2.6.2.2 Clés explicites\nLa table airports, contient des informations supplémentaires sur les aéroports : nom complet, altitude, position géographique, etc. Chaque aéroport est identifié par un code contenu dans la colonne faa.\nSi on regarde la table flights, on voit que le code d’identification des aéroports apparaît à deux endroits différents : pour l’aéroport de départ dans la colonne origin, et pour celui d’arrivée dans la colonne dest. On a donc deux clés de jointure possibles, et qui portent un nom différent de la clé de airports.\nOn va commencer par fusionner les données concernant l’aéroport de départ. Pour simplifier l’affichage des résultats, on va se contenter d’un sous-ensemble des deux tables :\n\nflights_ex &lt;- flights %&gt;% select(month, day, origin, dest)\nairports_ex &lt;- airports %&gt;% select(faa, alt, name)\n\nSi on se contente d’un left_join comme à l’étape précédente, on obtient un message d’erreur car aucune colonne commune ne peut être identifiée comme clé de jointure :\n\nflights_ex %&gt;% left_join(airports_ex)\n#&gt; Error in `left_join()`:\n#&gt; ! `by` must be supplied when `x` and `y` have no common variables.\n#&gt; ℹ Use `cross_join()` to perform a cross-join.\n\nOn doit donc spécifier explicitement les clés avec l’argument by de left_join. Ici la clé est nommée origin dans la première table, et faa dans la seconde. La syntaxe est donc la suivante :\n\nflights_ex %&gt;% \n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n#&gt; # A tibble: 336,776 × 6\n#&gt;    month   day origin dest    alt name               \n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;              \n#&gt;  1     1     1 EWR    IAH      18 Newark Liberty Intl\n#&gt;  2     1     1 LGA    IAH      22 La Guardia         \n#&gt;  3     1     1 JFK    MIA      13 John F Kennedy Intl\n#&gt;  4     1     1 JFK    BQN      13 John F Kennedy Intl\n#&gt;  5     1     1 LGA    ATL      22 La Guardia         \n#&gt;  6     1     1 EWR    ORD      18 Newark Liberty Intl\n#&gt;  7     1     1 EWR    FLL      18 Newark Liberty Intl\n#&gt;  8     1     1 LGA    IAD      22 La Guardia         \n#&gt;  9     1     1 JFK    MCO      13 John F Kennedy Intl\n#&gt; 10     1     1 LGA    ORD      22 La Guardia         \n#&gt; # ℹ 336,766 more rows\n\nOn constate que les deux nouvelles colonnes name et alt contiennent bien les données correspondant à l’aéroport de départ.\nOn va stocker le résultat de cette jointure dans la table flights_ex :\n\nflights_ex &lt;- flights_ex %&gt;%\n  left_join(airports_ex, by = c(\"origin\" = \"faa\"))\n\nSupposons qu’on souhaite maintenant fusionner à nouveau les informations de la table airports, mais cette fois pour les aéroports d’arrivée de notre nouvelle table flights_ex. Les deux clés sont donc désormais dest dans la première table, et faa dans la deuxième. La syntaxe est donc la suivante :\n\nflights_ex %&gt;%\n  left_join(airports_ex, by = c(\"dest\" = \"faa\"))\n#&gt; # A tibble: 336,776 × 8\n#&gt;    month   day origin dest  alt.x name.x              alt.y name.y              \n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;               \n#&gt;  1     1     1 EWR    IAH      18 Newark Liberty Intl    97 George Bush Interco…\n#&gt;  2     1     1 LGA    IAH      22 La Guardia             97 George Bush Interco…\n#&gt;  3     1     1 JFK    MIA      13 John F Kennedy Intl     8 Miami Intl          \n#&gt;  4     1     1 JFK    BQN      13 John F Kennedy Intl    NA &lt;NA&gt;                \n#&gt;  5     1     1 LGA    ATL      22 La Guardia           1026 Hartsfield Jackson …\n#&gt;  6     1     1 EWR    ORD      18 Newark Liberty Intl   668 Chicago Ohare Intl  \n#&gt;  7     1     1 EWR    FLL      18 Newark Liberty Intl     9 Fort Lauderdale Hol…\n#&gt;  8     1     1 LGA    IAD      22 La Guardia            313 Washington Dulles I…\n#&gt;  9     1     1 JFK    MCO      13 John F Kennedy Intl    96 Orlando Intl        \n#&gt; 10     1     1 LGA    ORD      22 La Guardia            668 Chicago Ohare Intl  \n#&gt; # ℹ 336,766 more rows\n\nCela fonctionne, les informations de l’aéroport d’arrivée ont bien été ajoutées, mais on constate que les colonnes ont été renommées. En effet, ici les deux tables fusionnées contenaient toutes les deux des colonnes name et alt. Comme on ne peut pas avoir deux colonnes avec le même nom dans un tableau, dplyr a renommé les colonnes de la première table en name.x et alt.x, et celles de la deuxième en name.y et alt.y.\nC’est pratique, mais pas forcément très parlant. On pourrait renommer manuellement les colonnes avec rename avant de faire la jointure pour avoir des intitulés plus explicites, mais on peut aussi utiliser l’argument suffix de left_join, qui permet d’indiquer les suffixes à ajouter aux colonnes.\n\nflights_ex %&gt;%\n  left_join(\n    airports_ex,\n    by = c(\"dest\" = \"faa\"),\n    suffix = c(\"_depart\", \"_arrivee\")\n  )\n#&gt; # A tibble: 336,776 × 8\n#&gt;    month   day origin dest  alt_depart name_depart      alt_arrivee name_arrivee\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;                  &lt;dbl&gt; &lt;chr&gt;       \n#&gt;  1     1     1 EWR    IAH           18 Newark Liberty …          97 George Bush…\n#&gt;  2     1     1 LGA    IAH           22 La Guardia                97 George Bush…\n#&gt;  3     1     1 JFK    MIA           13 John F Kennedy …           8 Miami Intl  \n#&gt;  4     1     1 JFK    BQN           13 John F Kennedy …          NA &lt;NA&gt;        \n#&gt;  5     1     1 LGA    ATL           22 La Guardia              1026 Hartsfield …\n#&gt;  6     1     1 EWR    ORD           18 Newark Liberty …         668 Chicago Oha…\n#&gt;  7     1     1 EWR    FLL           18 Newark Liberty …           9 Fort Lauder…\n#&gt;  8     1     1 LGA    IAD           22 La Guardia               313 Washington …\n#&gt;  9     1     1 JFK    MCO           13 John F Kennedy …          96 Orlando Intl\n#&gt; 10     1     1 LGA    ORD           22 La Guardia               668 Chicago Oha…\n#&gt; # ℹ 336,766 more rows\n\nOn obtient ainsi directement des noms de colonnes nettement plus clairs.\n\n\n\n2.6.3 Types de jointures\nJusqu’à présent nous avons utilisé la fonction left_join, mais il existe plusieurs types de jointures.\nPartons de deux tables d’exemple, personnes et voitures :\n\npersonnes &lt;- tibble(\n    nom = c(\"Sylvie\", \"Sylvie\", \"Monique\", \"Gunter\", \"Rayan\", \"Rayan\"),\n    voiture = c(\"Twingo\", \"Ferrari\", \"Scenic\", \"Lada\", \"Twingo\", \"Clio\")\n)\n\n\n\n\n\n\nnom\nvoiture\n\n\n\n\nSylvie\nTwingo\n\n\nSylvie\nFerrari\n\n\nMonique\nScenic\n\n\nGunter\nLada\n\n\nRayan\nTwingo\n\n\nRayan\nClio\n\n\n\n\n\n\nvoitures &lt;- tibble(\n    voiture = c(\"Twingo\", \"Ferrari\", \"Clio\", \"Lada\", \"208\"),\n    vitesse = c(\"140\", \"280\", \"160\", \"85\", \"160\")\n)\n\n\n\n\n\n\nvoiture\nvitesse\n\n\n\n\nTwingo\n140\n\n\nFerrari\n280\n\n\nClio\n160\n\n\nLada\n85\n\n\n208\n160\n\n\n\n\n\n\n2.6.3.1 left_join\nSi on fait un left_join de voitures sur personnes :\n\npersonnes %&gt;% left_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nOn voit que chaque ligne de personnes est bien présente, et qu’on lui a ajouté une ligne de voitures correspondante si elle existe. Dans le cas du Scenic, il n’y a avait pas de ligne dans voitures, donc vitesse a été mise à NA. Dans le cas de 208, présente dans voitures mais pas dans personnes, la ligne n’apparaît pas.\nSi on fait un left_join cette fois de personnes sur voitures, c’est l’inverse :\n\nvoitures %&gt;% left_join(personnes)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nvoiture\nvitesse\nnom\n\n\n\n\nTwingo\n140\nSylvie\n\n\nTwingo\n140\nRayan\n\n\nFerrari\n280\nSylvie\n\n\nClio\n160\nRayan\n\n\nLada\n85\nGunter\n\n\n208\n160\nNA\n\n\n\n\n\nLa ligne 208 est là, mais nom est à NA. Par contre Monique est absente. Et on remarquera que la ligne Twingo, présente deux fois dans personnes, a été dupliquée pour être associée aux deux lignes de données de Sylvie et Rayan.\nEn résumé, quand on fait un left_join(x, y), toutes les lignes de x sont présentes, et dupliquées si nécessaire quand elles apparaissent plusieurs fois dans y. Les lignes de y non présentes dans x disparaissent. Les lignes de x non présentes dans y se voient attribuer des NA pour les nouvelles colonnes.\nIntuitivement, on pourrait considérer que left_join(x, y) signifie “ramener l’information de la table y sur la table x”.\nEn général, left_join sera le type de jointures le plus fréquemment utilisé.\n\n\n2.6.3.2 right_join\nLa jointure right_join est l’exacte symétrique de left_join, c’est-à dire que right_join(x, y) est équivalent à left_join(y, x) :\n\npersonnes %&gt;% right_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160\n\n\n\n\n\n\n\n2.6.3.3 inner_join\nDans le cas de inner_join(x, y), seules les lignes présentes à la fois dans x et y sont conservées (et si nécessaire dupliquées) dans la table résultat :\n\npersonnes %&gt;% inner_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\n\n\n\nIci la ligne 208 est absente, ainsi que la ligne Monique, qui dans le cas d’un left_join avait été conservée et s’était vue attribuer une vitesse à NA.\n\n\n2.6.3.4 full_join\nDans le cas de full_join(x, y), toutes les lignes de x et toutes les lignes de y sont conservées (avec des NA ajoutés si nécessaire) même si elles sont absentes de l’autre table :\n\npersonnes %&gt;% full_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\nvitesse\n\n\n\n\nSylvie\nTwingo\n140\n\n\nSylvie\nFerrari\n280\n\n\nMonique\nScenic\nNA\n\n\nGunter\nLada\n85\n\n\nRayan\nTwingo\n140\n\n\nRayan\nClio\n160\n\n\nNA\n208\n160\n\n\n\n\n\n\n\n2.6.3.5 semi_join et anti_join\nsemi_join et anti_join sont des jointures filtrantes, c’est-à-dire qu’elles sélectionnent les lignes de x sans ajouter les colonnes de y.\nAinsi, semi_join ne conservera que les lignes de x pour lesquelles une ligne de y existe également, et supprimera les autres. Dans notre exemple, la ligne Monique est donc supprimée :\n\npersonnes %&gt;% semi_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\n\n\n\n\nSylvie\nTwingo\n\n\nSylvie\nFerrari\n\n\nGunter\nLada\n\n\nRayan\nTwingo\n\n\nRayan\nClio\n\n\n\n\n\nUn anti_join fait l’inverse, il ne conserve que les lignes de x absentes de y. Dans notre exemple, on ne garde donc que la ligne Monique :\n\npersonnes %&gt;% anti_join(voitures)\n\n\n#&gt; Joining with `by = join_by(voiture)`\n\n\n\n\nnom\nvoiture\n\n\n\n\nMonique\nScenic",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#ressources",
    "href": "filter.html#ressources",
    "title": "2  Manipuler les données",
    "section": "2.7 Ressources",
    "text": "2.7 Ressources\nToutes les ressources ci-dessous sont en anglais…\nLe livre R for data science, librement accessible en ligne, contient plusieurs chapitres très complets sur la manipulation des données, notamment :\n\nData transformation pour les manipulations\nRelational data pour les tables multiples\n\nLe site de l’extension comprend une liste des fonctions et les pages d’aide associées, mais aussi une introduction au package et plusieurs articles dont un spécifiquement sur les jointures.\nEnfin, une “antisèche” très synthétique est également accessible depuis RStudio, en allant dans le menu Help puis Cheatsheets et Data Transformation with dplyr.",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "filter.html#footnotes",
    "href": "filter.html#footnotes",
    "title": "2  Manipuler les données",
    "section": "",
    "text": "À noter que cette opération est un peu plus “fragile” que les autres, car si l’ordre des colonnes change elle peut renvoyer un résultat différent.↩︎\nIl est également possible de renommer des colonnes directement avec select, avec la même syntaxe que pour rename.↩︎\nLe pipe a été introduit à l’origine par l’extension magrittr, et repris par dplyr↩︎",
    "crumbs": [
      "Le tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Manipuler les données</span>"
    ]
  },
  {
    "objectID": "combinatoire.html",
    "href": "combinatoire.html",
    "title": "3  La combinatoire",
    "section": "",
    "text": "3.1 La factorielle\nPour calculer la factorielle d’un nombre en R, il faut utiliser la commande factorial. Par exemple, si nous voulons calculer 6!:\nfactorial(6)\n#&gt; [1] 720",
    "crumbs": [
      "Les probabilités et la combinatoire",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La combinatoire</span>"
    ]
  },
  {
    "objectID": "combinatoire.html#les-combinaisons",
    "href": "combinatoire.html#les-combinaisons",
    "title": "3  La combinatoire",
    "section": "3.2 Les combinaisons",
    "text": "3.2 Les combinaisons\nPour calculer le nombre de combinaisons lorsque nous choisissons \\(k\\) objets parmi \\(n\\) (sans ordre), c’est-à-dire \\(C_k^n\\), nous utilisons la commande choose(n,k). Par exemple, si nous voulons calculer le nombre de combinaisons possibles au loto 6-49, \\(C_6^{49}\\), nous avons:\n\nchoose(49,6)\n#&gt; [1] 13983816",
    "crumbs": [
      "Les probabilités et la combinatoire",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La combinatoire</span>"
    ]
  },
  {
    "objectID": "combinatoire.html#les-arrangements",
    "href": "combinatoire.html#les-arrangements",
    "title": "3  La combinatoire",
    "section": "3.3 Les arrangements",
    "text": "3.3 Les arrangements\nPour calculer le nombre d’arrangements lorsque nous choisissons \\(k\\) objets parmi \\(n\\) (avec ordre), c’est-à-dire \\(A_k^n\\), nous utilisons les commandes choose(n,k) et factorial. En effet, nous savons que:\n\\[\\begin{equation}\nA_k^n = C_k^n \\cdot k!\n\\end{equation}\\]\net donc on peut calculer un arrangement en effectuant choose(n,k)*factorial(k). Si nous voulons calculer le nombre de comités de 5 personnes nous pouvons former en choisissant parmi 12 personnes, \\(A_5^{12}\\), nous avons:\n\nchoose(12,5)*factorial(5)\n#&gt; [1] 95040",
    "crumbs": [
      "Les probabilités et la combinatoire",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>La combinatoire</span>"
    ]
  },
  {
    "objectID": "lois_probabilites.html",
    "href": "lois_probabilites.html",
    "title": "4  Les lois de probabilités",
    "section": "",
    "text": "4.1 Les lois de probabilités discrètes",
    "crumbs": [
      "Les probabilités et la combinatoire",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les lois de probabilités</span>"
    ]
  },
  {
    "objectID": "lois_probabilites.html#les-lois-de-probabilités-discrètes",
    "href": "lois_probabilites.html#les-lois-de-probabilités-discrètes",
    "title": "4  Les lois de probabilités",
    "section": "",
    "text": "4.1.1 La loi binomiale\nLe nom racine pour la loi binomiale est binom.\nSoit \\(X\\): le nombre de succès en \\(n\\) essais et \\(X\\sim B(n,p)\\). Voici la façon de calculer des probabilités pour la loi binomiale à l’aide de R:\n\n\n\nProbabilités\nCommande R\n\n\n\n\n\\(P(X=k)\\)\ndbinom(k, n, p)\n\n\n\\(P(i\\leq X \\leq j)\\)\nsum(dbinom(i:j, n, p))\n\n\n\\(P(X\\leq k)\\)\npbinom(k, n, p)\n\n\n\\(P(X&gt;k)\\)\n1-pbinom(k, n, p)\n\n\n\nSoit \\(X\\) la variable aléatoire comptant le nombre de face 2 que nous obtenons en lançant un dé à quatre reprises. Nous avons que \\(X\\sim B(4,\\frac{1}{6})\\). Si nous voulons calculer \\(P(X=3)\\), nous aurons:\n\ndbinom(3,4,1/6)\n#&gt; [1] 0.0154321\n\nNous avons donc une probabilité de 1.5432099% d’obtenir 3 fois la face deux en lançant un dé à quatres reprises.\n\n\n4.1.2 La loi de Poisson\nLe nom racine pour la loi de Poisson est pois.\nSoit \\(X\\): le nombre d’événements dans un intervalle fixé et \\(X\\sim Po(\\lambda)\\). Voici la façon de calculer des probabilités pour la loi de Poisson à l’aide de R:\n\n\n\nProbabilités\nCommande R\n\n\n\n\n\\(P(X=k)\\)\ndpois(k, lambda)\n\n\n\\(P(i\\leq X \\leq j)\\)\nsum(dpois(i:j, lambda))\n\n\n\\(P(X\\leq k)\\)\nppois(k, lambda)\n\n\n\\(P(X&gt;k)\\)\n1-ppois(k, lambda)\n\n\n\nSoit \\(X\\) le nombre d’erreurs dans une page. Si une page contient en moyenne une demie erreur alors \\(X\\sim Po(1/2)\\). Si nous voulons calculer \\(P(X=2)\\), nous aurons:\n\ndpois(2, 1/2)\n#&gt; [1] 0.07581633\n\nNous avons donc une probabilité de 7.5816332% d’obtenir deux erreurs sur une page.\n\n\n4.1.3 La loi géométrique\nLe nom racine pour la loi géométrique est geom.\nSoit \\(X\\): le nombre d’échecs avant d’obtenir un succès et \\(X\\sim G(p)\\). Voici la façon de calculer des probabilités pour la loi géométrique à l’aide de R:\n\n\n\nProbabilités\nCommande R\n\n\n\n\n\\(P(X=k)\\)\ndgeom(k, p)\n\n\n\\(P(i\\leq X \\leq j)\\)\nsum(dgeom(i:j, p))\n\n\n\\(P(X\\leq k)\\)\npgeom(k, p)\n\n\n\\(P(X&gt;k)\\)\n1-pgeom(k, p)\n\n\n\nSoit \\(X\\) le nombre d’échecs avant d’avoir un premier succès. Si la probabilité de succès est \\(\\frac{1}{5}\\) alors \\(X\\sim G(1/5)\\). Si nous voulons calculer \\(P(X=6)\\), nous aurons:\n\ndgeom(6, 1/5)\n#&gt; [1] 0.0524288\n\nNous avons donc une probabilité de 5.24288% d’obtenir 6 échecs avant un premier succès.\n\nRemarque : Pour la loi géométrique, on rencontre parfois cette définition : la probabilité p’(k) est la probabilité, lors d’une succession d’épreuves de Bernoulli indépendantes, d’obtenir k échecs avant un succès. On remarque qu’il ne s’agit que d’un décalage de la précédente loi géométrique. Si \\(X\\) suit la loi \\(p\\), alors \\(X+1\\) suit la loi \\(p'\\).\n\n\n\n4.1.4 La loi hypergéométrique\nLe nom racine pour la loi hypergéométrique est hyper.\nOn tire sans remise \\(n\\) objets d’un ensemble de \\(N\\) objets dont \\(A\\) possèdent une caractéristique particulière (et les autres \\(B=N-A\\) ne la possèdent pas). Soit \\(X\\) le nombre d’objets de l’échantillon qui possèdent la caractéristique. Nous avons que \\(X\\sim H(N,A,n)\\).\nVoici la façon de calculer des probabilités pour la loi hypergéométrique à l’aide de R:\n\n\n\nProbabilités\nCommande R\n\n\n\n\n\\(P(X=k)\\)\ndhyper(k, A, B, n)\n\n\n\\(P(i\\leq X \\leq j)\\)\nsum(dhyper(i:j, A, B, n))\n\n\n\\(P(X\\leq k)\\)\nphyper(k, A, B, n)\n\n\n\\(P(X&gt;k)\\)\n1-phyper(k, A, B, n)\n\n\n\nSoit \\(X\\) le nombre de boules blanches de l’échantillon de taille 4. Si l’urne contient 5 boules blanches et 8 boules noires, nous avons \\(X\\sim H(13,5,4)\\). Si nous voulons calculer \\(P(X=2)\\), nous aurons:\n\ndhyper(2, 5, 8, 4)\n#&gt; [1] 0.3916084\n\nNous avons donc une probabilité de 39.1608392% de piger 2 boules blanches dans un échantillon de taille 4.",
    "crumbs": [
      "Les probabilités et la combinatoire",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les lois de probabilités</span>"
    ]
  },
  {
    "objectID": "lois_probabilites.html#les-lois-de-probabilités-continues",
    "href": "lois_probabilites.html#les-lois-de-probabilités-continues",
    "title": "4  Les lois de probabilités",
    "section": "4.2 Les lois de probabilités continues",
    "text": "4.2 Les lois de probabilités continues\n\n4.2.1 La loi normale\nLe nom racine pour la loi normale est norm.\nSi \\(X\\) suit une loi normale de moyenne \\(\\mu\\) et de variance \\(\\sigma^2\\), nous avons \\(X\\sim N(\\mu,\\sigma^2)\\).\nVoici la façon de calculer des probabilités pour la loi normale à l’aide de R:\n\n\n\nProbabilités\nCommande R\n\n\n\n\n\\(P(i\\leq X \\leq j)\\)\npnorm(j, mu, sigma)-pnorm(i, mu, sigma)\n\n\n\\(P(X\\leq k)\\)\npnorm(k, mu, sigma)\n\n\n\\(P(X&gt;k)\\)\n1-pnorm(k, mu, sigma)\n\n\n\nSoit \\(X\\sim N(3,25)\\) une variable aléatoire suivant une loi normale de moyenne 3 et de variance 25. Si nous voulons calculer la probabilité \\(P(1.25&lt;X&lt;3.6)\\) en R, nous pouvons utiliser la commande suivante:\n\npnorm(3.6, 3, 5) - pnorm(1.25, 3, 5)\n#&gt; [1] 0.1845891\n\nLa probabilité que notre variable aléatoire se trouve entre 1.25 et 3.6 est donc 18.4589077 %.\n\n\n4.2.2 La loi de Student\nLe nom racine pour la loi de Student est t.\nSi \\(X\\) suit une loi de Student à \\(\\nu\\) degrés de liberté, nous avons \\(X\\sim T_{\\nu}\\).\nVoici la façon de calculer des probabilités pour la loi de Student à l’aide de R:\n\n\n\nProbabilités\nCommande R\n\n\n\n\n\\(P(i\\leq X \\leq j)\\)\npt(j, nu)-pt(i, nu)\n\n\n\\(P(X\\leq k)\\)\npt(k, nu)\n\n\n\\(P(X&gt;k)\\)\n1-pt(k, nu)\n\n\n\nSoit \\(X\\sim T_5\\) une variable aléatoire suivant une loi de Student à 5 degrés de liberté. Si nous voulons calculer la probabilité \\(P(X&gt;3)\\) en R, nous pouvons utiliser la commande suivante:\n\n1 - pt(3, 5)\n#&gt; [1] 0.01504962\n\nLa probabilité que notre variable aléatoire soit plus grande que 3 est donc 1.5049624 %.",
    "crumbs": [
      "Les probabilités et la combinatoire",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Les lois de probabilités</span>"
    ]
  },
  {
    "objectID": "tableaux.html",
    "href": "tableaux.html",
    "title": "5  Les tableaux",
    "section": "",
    "text": "5.1 Tableau de fréquences à une variable",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les tableaux</span>"
    ]
  },
  {
    "objectID": "tableaux.html#tableau-de-fréquences-à-une-variable",
    "href": "tableaux.html#tableau-de-fréquences-à-une-variable",
    "title": "5  Les tableaux",
    "section": "",
    "text": "5.1.1 Les variables qualitatives\nLe tableau de fréquences que nous utiliserons est le suivant:\n\n\n\n\n\n\n\n\nTitre\n\n\n\n\n\n\nNom de la variable\nNombre d’unités statistiques\nPourcentage d’unités statistiques (%)\n\n\n(Modalités)\n(Fréquences absolues)\n(Fréquences relatives)\n\n\nTotal\nn\n100%\n\n\n\n\nImportant : Le titre doit toujours être indiqué lors de la construction d’un tableau de fréquence.\n\nLorsque les données se trouvent dans une tibble dans R, il est possible d’utiliser la commande freq de la librairie questionr pour afficher le tableau de fréquences. La commande freq prend comme argument la variable dont vous voulez produire le tableau de fréquences. Pour obtenir une sortie adéquate, il faut ajouter trois options à la commande:\n\ncum = FALSE; permet de ne pas afficher les pourcentages cumulés\nvalid = FALSE; permet de ne pas afficher les données manquantes\ntotal = TRUE; permet d’afficher le total\n\nDans la base de données nycflights13::planes, nous allons afficher la variable engine, qui correspond au type de moteur de l’avion.\n\nfreq(planes$engine,cum = FALSE,valid = FALSE,total = TRUE)\n#&gt;                  n     %\n#&gt; 4 Cycle          2   0.1\n#&gt; Reciprocating   28   0.8\n#&gt; Turbo-fan     2750  82.8\n#&gt; Turbo-jet      535  16.1\n#&gt; Turbo-prop       2   0.1\n#&gt; Turbo-shaft      5   0.2\n#&gt; Total         3322 100.0\n\n\n\n5.1.2 Les variables quantitatives discrètes\nLe tableau de fréquences que nous utiliserons est le suivant :\n\n\n\n\n\n\n\n\n\nTitre\n\n\n\n\n\n\n\nNom de la variable\nNombre d’unités statistiques\nPourcentage d’unités statistiques (%)\nPourcentage cumulé\n\n\n(Valeurs)\n(Fréquences absolues)\n(Fréquences relatives)\n(Fréquences relatives cumulées)\n\n\nTotal\nn\n100%\n\n\n\n\nLe pourcentage cumulé permet de déterminer le pourcentage des répondants qui ont indiqué la valeur correspondante, ou une plus petite. Il sert à donner une meilleure vue d’ensemble.\n\nSi pour la valeur \\(x_i\\) de la variable \\(A\\) la pourcentage cumulé est de \\(b\\) %, ceci signifie que \\(b\\) % des valeurs de la variable \\(A\\) sont plus petites ou égales à \\(x_i\\).\n\nLa commande freq prend comme argument la variable dont vous voulez produire le tableau de fréquences. Pour obtenir une sortie adéquate, il faut ajouter trois options à la commande:\n\ncum = TRUE; permet d’afficher les pourcentages cumulés\nvalid = FALSE; permet de ne pas afficher les données manquantes\ntotal = TRUE; permet d’afficher le total\n\nDans la base de données nycflights13::planes, nous allons afficher la variable engines, qui correspond au nombre de moteurs de l’avion.\n\nfreq(planes$engines,cum = TRUE,valid = FALSE,total = TRUE)\n#&gt;          n     %  %cum\n#&gt; 1       27   0.8   0.8\n#&gt; 2     3288  99.0  99.8\n#&gt; 3        3   0.1  99.9\n#&gt; 4        4   0.1 100.0\n#&gt; Total 3322 100.0 100.0\n\nDans la base de données nycflights13::planes, nous allons afficher la variable seats, qui correspond au nombre de sièges de l’avion.\n\nfreq(planes$seats,cum = TRUE,valid = FALSE,total = TRUE)\n#&gt;          n     %  %cum\n#&gt; 2       16   0.5   0.5\n#&gt; 4        5   0.2   0.6\n#&gt; 5        2   0.1   0.7\n#&gt; 6        3   0.1   0.8\n#&gt; 7        2   0.1   0.8\n#&gt; 8        5   0.2   1.0\n#&gt; 9        1   0.0   1.0\n#&gt; 10       1   0.0   1.1\n#&gt; 11       2   0.1   1.1\n#&gt; 12       1   0.0   1.1\n#&gt; 14       1   0.0   1.2\n#&gt; 16       1   0.0   1.2\n#&gt; 20      80   2.4   3.6\n#&gt; 22       2   0.1   3.7\n#&gt; 55     390  11.7  15.4\n#&gt; 80      83   2.5  17.9\n#&gt; 95     123   3.7  21.6\n#&gt; 100    102   3.1  24.7\n#&gt; 102      1   0.0  24.7\n#&gt; 128      1   0.0  24.7\n#&gt; 139      8   0.2  25.0\n#&gt; 140    411  12.4  37.4\n#&gt; 142    158   4.8  42.1\n#&gt; 145     57   1.7  43.8\n#&gt; 147      3   0.1  43.9\n#&gt; 149    452  13.6  57.5\n#&gt; 172     81   2.4  60.0\n#&gt; 178    283   8.5  68.5\n#&gt; 179    134   4.0  72.5\n#&gt; 182    159   4.8  77.3\n#&gt; 189     73   2.2  79.5\n#&gt; 191     87   2.6  82.1\n#&gt; 199     43   1.3  83.4\n#&gt; 200    256   7.7  91.1\n#&gt; 222     13   0.4  91.5\n#&gt; 255     16   0.5  92.0\n#&gt; 260      4   0.1  92.1\n#&gt; 269      1   0.0  92.1\n#&gt; 275     25   0.8  92.9\n#&gt; 290      6   0.2  93.1\n#&gt; 292     16   0.5  93.6\n#&gt; 300     17   0.5  94.1\n#&gt; 330    114   3.4  97.5\n#&gt; 375      1   0.0  97.5\n#&gt; 377     14   0.4  98.0\n#&gt; 379     55   1.7  99.6\n#&gt; 400     12   0.4 100.0\n#&gt; 450      1   0.0 100.0\n#&gt; Total 3322 100.0 100.0\n\nComme nous pouvons le constater, le tableau est très grand car la variable seats possède 48 valeurs différentes.\n\n\n5.1.3 Les variables quantitatives continues\nLe tableau de fréquences que nous utiliserons est le suivant :\n\n\n\n\n\n\n\n\n\nTitre\n\n\n\n\n\n\n\nNom de la variable\nNombre d’unités statistiques\nPourcentage d’unités statistiques (%)\nPourcentage cumulé\n\n\n(Classes)\n(Fréquences absolues)\n(Fréquences relatives)\n(Fréquences relatives cumulées)\n\n\nTotal\nn\n100%\n\n\n\n\nPour être en mesure de briser une variable en classes, il faut utiliser la commande cut.\nLes options de cut sont:\n\ninclude.lowest = TRUE qui permet d’avoir un intervalle fermé à droite et ouvert à gauche;\nbreaks qui permet d’indiquer à quel endroit on doit créer les classes;\nseq(from = A, to = B, by = C) permet de créer un vecteur comportant les valeurs de A jusqu’à B en faisant des bonds de C.\n\nPour simplifier le code, nous créons en premier lieu une variable air_time_rec avec les classes et nous l’affichons ensuite avec freq. Remarquons que nous avons ajouté l’option valid = TRUE car certaines valeurs sont manquantes. Rappelons que les données manquantes sont représentées par NA en R. Deux colonnes sont ajoutées:\n\nval%: le pourcentage en omettant les valeurs manquantes\nval%cum: le pourcentage cumulé en omettant les valeurs manquantes\n\nNous obtenons donc:\n\nair_time_rec &lt;- cut(flights$air_time, \n                    right=FALSE,\n                    breaks=seq(from = 0, to = 700, by = 100))\nfreq(air_time_rec,cum = TRUE,total = TRUE,valid = TRUE)\n#&gt;                n     %  val%  %cum val%cum\n#&gt; [0,100)   105687  31.4  32.3  31.4    32.3\n#&gt; [100,200) 146527  43.5  44.8  74.9    77.0\n#&gt; [200,300)  31036   9.2   9.5  84.1    86.5\n#&gt; [300,400)  43347  12.9  13.2  97.0    99.8\n#&gt; [400,500)     48   0.0   0.0  97.0    99.8\n#&gt; [500,600)    132   0.0   0.0  97.0    99.8\n#&gt; [600,700)    569   0.2   0.2  97.2   100.0\n#&gt; NA          9430   2.8    NA 100.0      NA\n#&gt; Total     336776 100.0 100.0 100.0   100.0",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les tableaux</span>"
    ]
  },
  {
    "objectID": "tableaux.html#tableau-de-fréquences-à-deux-variables",
    "href": "tableaux.html#tableau-de-fréquences-à-deux-variables",
    "title": "5  Les tableaux",
    "section": "5.2 Tableau de fréquences à deux variables",
    "text": "5.2 Tableau de fréquences à deux variables\nFaire une analyse bivariée, c’est étudier la relation entre deux variables : sont-elles liées ? les valeurs de l’une influencent-elles les valeurs de l’autre ? ou sont-elles au contraire indépendantes ?\nÀ noter qu’on va parler ici d’influence ou de lien, mais pas de relation de cause à effet. Les outils présentés permettent de visualiser ou de déterminer une relation, mais la mise en évidence de liens de causalité proprement dit est nettement plus complexe : il faut en effet vérifier que c’est bien telle variable qui influence telle autre et pas l’inverse, qu’il n’y a pas de “variable cachée”, etc.\nLà encore, le type d’analyse ou de visualisation est déterminé par la nature qualitative ou quantitative des deux variables.\n\n5.2.1 Croisement de deux variables qualitatives\nOn continue à travailler avec le jeu de données tiré de l’enquête Histoire de vie inclus dans l’extension questionr. On commence donc par charger l’extension, le jeu de données, et à le renommer en un nom plus court pour gagner un peu de temps de saisie au clavier.\n\nlibrary(questionr)\ndata(hdv2003)\nd &lt;- hdv2003\n\nQuand on veut croiser deux variables qualitatives, on fait un tableau croisé. Comme pour un tri à plat ceci s’obtient avec la fonction table de R, mais à laquelle on passe cette fois deux variables en argument. Par exemple, si on veut croiser la catégorie socio-professionnelle et le sexe des enquêtés :\n\ntable(d$qualif, d$sexe)\n#&gt;                           \n#&gt;                            Homme Femme\n#&gt;   Ouvrier specialise          96   107\n#&gt;   Ouvrier qualifie           229    63\n#&gt;   Technicien                  66    20\n#&gt;   Profession intermediaire    88    72\n#&gt;   Cadre                      145   115\n#&gt;   Employe                     96   498\n#&gt;   Autre                       21    37\n\nPour pouvoir interpréter ce tableau on doit passer du tableau en effectifs au tableau en pourcentages ligne ou colonne. Pour cela, on peut utiliser les fonctions lprop et cprop de l’extension questionr, qu’on applique au tableau croisé précédent.\nPour calculer les pourcentages ligne :\n\ntab &lt;- table(d$qualif, d$sexe)\nlprop(tab)\n#&gt;                           \n#&gt;                            Homme Femme Total\n#&gt;   Ouvrier specialise        47.3  52.7 100.0\n#&gt;   Ouvrier qualifie          78.4  21.6 100.0\n#&gt;   Technicien                76.7  23.3 100.0\n#&gt;   Profession intermediaire  55.0  45.0 100.0\n#&gt;   Cadre                     55.8  44.2 100.0\n#&gt;   Employe                   16.2  83.8 100.0\n#&gt;   Autre                     36.2  63.8 100.0\n#&gt;   All                       44.8  55.2 100.0\n\nEt pour les pourcentages colonne :\n\ncprop(tab)\n#&gt;                           \n#&gt;                            Homme Femme All  \n#&gt;   Ouvrier specialise        13.0  11.7  12.3\n#&gt;   Ouvrier qualifie          30.9   6.9  17.7\n#&gt;   Technicien                 8.9   2.2   5.2\n#&gt;   Profession intermediaire  11.9   7.9   9.7\n#&gt;   Cadre                     19.6  12.6  15.7\n#&gt;   Employe                   13.0  54.6  35.9\n#&gt;   Autre                      2.8   4.1   3.5\n#&gt;   Total                    100.0 100.0 100.0",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Les tableaux</span>"
    ]
  },
  {
    "objectID": "ggplot2.html",
    "href": "ggplot2.html",
    "title": "6  Les graphiques",
    "section": "",
    "text": "6.1 Initialisation\nUn graphique ggplot2 s’initialise à l’aide de la fonction ggplot(). Les données représentées graphiquement sont toujours issues d’un tableau de données (data frame ou tibble), qu’on passe en argument data à la fonction :\nggplot(data = rp)\n## Ou, équivalent\nggplot(rp)\nOn a défini la source de données, il faut maintenant ajouter des éléments de représentation graphique. Ces éléments sont appelés des geom, et on les ajoute à l’objet graphique de base avec l’opérateur +.\nUn des geom les plus simples est geom_histogram. On peut l’ajouter de la manière suivante :\nggplot(rp) +\n    geom_histogram()\nReste à indiquer quelle donnée nous voulons représenter sous forme d’histogramme. Cela se fait à l’aide d’arguments passés via la fonction aes(). Ici nous avons un paramètre à renseigner, x, qui indique la variable à représenter sur l’axe des x (l’axe horizontal). Ainsi, si on souhaite représenter la distribution des communes du jeu de données selon le pourcentage de cadres dans leur population active (variable cadres), on pourra faire :\nggplot(rp) +\n    geom_histogram(aes(x = cadres))\nSi on veut représenter une autre variable, il suffit de changer la valeur de x :\nggplot(rp) +\n    geom_histogram(aes(x = ouvr))\nCertains geom prennent plusieurs paramètres. Ainsi, si on veut représenter un nuage de points, on peut le faire en ajoutant un geom_point. On doit alors indiquer à la fois la position en x (la variable sur l’axe horizontal) et en y (la variable sur l’axe vertical) de ces points, il faut donc passer ces deux arguments à aes() :\nggplot(rp) +\n    geom_point(aes(x = dipl_sup, y = cadres))\nOn peut modifier certains attributs graphiques d’un geom en lui passant des arguments supplémentaires. Par exemple, pour un nuage de points, on peut modifier la couleur des points avec l’argument color, leur taille avec l’argument size, et leur transparence avec l’argument alpha :\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres),\n        color = \"darkgreen\", size = 3, alpha = 0.3\n    )\nOn notera que dans ce cas les arguments sont dans la fonction geom mais à l’extérieur du aes(). Plus d’explications sur ce point dans quelques instants.",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#initialisation",
    "href": "ggplot2.html#initialisation",
    "title": "6  Les graphiques",
    "section": "",
    "text": "Note\n\n\n\nQuand on spécifie une variable, inutile d’indiquer le nom du tableau de données sous la forme rp$ouvr, car ggplot2 recherche automatiquement la variable dans le tableau de données indiqué avec le paramètre data. On peut donc se contenter de ouvr.",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#les-titres",
    "href": "ggplot2.html#les-titres",
    "title": "6  Les graphiques",
    "section": "6.2 Les titres",
    "text": "6.2 Les titres\nPour ajouter un titre à votre graphique et pour ajouter des titres à vos axes x et y, nous utilisons la commande labs().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres)\n    ) +\n    labs(\n        title = \"Un titre magnifique\",\n        x = \"Le nombre d'années de scolarité\",\n        y = \"Le pourcentage de cadres dans la population acitve\"\n    )",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#exemples-de-geom",
    "href": "ggplot2.html#exemples-de-geom",
    "title": "6  Les graphiques",
    "section": "6.3 Exemples de geom",
    "text": "6.3 Exemples de geom\nIl existe un grand nombre de geom, décrits en détail dans la documentation officielle. Outre les geom_histogram et geom_point que l’on vient de voir, on pourra noter les geom suivants.\n\n6.3.1 geom_boxplot\ngeom_boxplot permet de représenter des boîtes à moustaches. On lui passe en y la variable numérique dont on veut étudier la répartition, et en x la variable qualitative contenant les classes qu’on souhaite comparer. Ainsi, si on veut comparer la répartition du pourcentage de maisons en fonction du département de la commune, on pourra faire :\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison))\n\n\n\n\n\n\n\n\nOn peut personnaliser la présentation avec différents argument supplémentaires comme fill ou color :\n\nggplot(rp) +\n    geom_boxplot(\n        aes(x = departement, y = maison),\n        fill = \"wheat\", color = \"tomato4\"\n    )\n\n\n\n\n\n\n\n\nUn autre argument utile, varwidth, permet de faire varier la largeur des boîtes en fonction des effectifs de la classe (donc, ici, en fonction du nombre de communes de chaque département) :\n\nggplot(rp) +\n    geom_boxplot(\n        aes(x = departement, y = maison), \n        varwidth = TRUE)\n\n\n\n\n\n\n\n\n\n\n6.3.2 geom_violin\ngeom_violin est très semblable à geom_boxplot, mais utilise des graphes en violon à la place des boîtes à moustache.\n\nggplot(rp) +\n    geom_violin(aes(x = departement, y = maison))\n\n\n\n\n\n\n\n\nLes graphes en violon peuvent donner une lecture plus fine des différences de distribution selon les classes. Comme pour les graphiques de densité, on peut faire varier le niveau de “détail” de la représentation en utilisant l’argument bw (bande passante).\n\nggplot(rp) +\n    geom_violin(\n        aes(x = departement, y = maison),\n        bw = 2\n    )\n\n\n\n\n\n\n\n\n\n\n6.3.3 geom_bar et geom_col\ngeom_bar permet de produire un graphique en bâtons (barplot). On lui passe en x la variable qualitative dont on souhaite représenter l’effectif de chaque modalité.\nPar exemple, si on veut afficher le nombre de communes de notre jeu de données pour chaque département :\n\nggplot(rp) +\n    geom_bar(aes(x = departement))\n\n\n\n\n\n\n\n\nSi on préfère avoir un graphique en barres horizontales, il suffit de passer la variable comme attribut y plutôt que x.\n\nggplot(rp) +\n    geom_bar(aes(y = departement))\n\n\n\n\n\n\n\n\nUne autre possibilité est d’utiliser coord_flip(), qui permet d’intervertir l’axe horizontal et l’axe vertical.\n\nggplot(rp) +\n    geom_bar(aes(x = departement)) +\n    coord_flip()\n\n\n\n\n\n\n\n\nÀ noter que coord_flip() peut s’appliquer à n’importe quel graphique ggplot2.\n\n\n6.3.4 geom_histogram\ngeom_histogram permet de représenter des histogrammes. On lui passe en x la variable quantitative dont on souhiate étudier la répartition.\n\nggplot(rp) +\n    geom_histogram(aes(x = cadres))\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nOn peut utiliser différents arguments, comme par exemple binwidth pour spécifier la largeur des rectangles de notre histogramme.\n\nggplot(rp) +\n    geom_histogram(aes(x = cadres), binwidth = 5)\n\n\n\n\n\n\n\n\n\n\n6.3.5 geom_freqpoly\ngeom_freqpoly permet d’afficher le polygone de fréquences d’une variable numérique. Son usage est similaire à celui de geom_histogram.\nAinsi, si on veut afficher le polygone de fréquences de la part des cadres dans les communes de notre jeu de données :\n\nggplot(rp) +\n    geom_freqpoly(aes(x = cadres))\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nOn peut utiliser différents arguments pour ajuster le calcul de l’estimation de densité, parmi lesquels kernel et bw (voir la page d’aide de la fonction density pour plus de détails). bw (abbréviation de bandwidth, bande passante) permet de régler la “finesse” de l’estimation de densité, un peu comme le choix du nombre de classes dans un histogramme :\n\nggplot(rp) +\n    geom_freqpoly(aes(x = cadres), binwidth = 5)\n\n\n\n\n\n\n\n\n\n\n6.3.6 geom_line\ngeom_line trace des lignes connectant les différentes observations entre elles. Il est notamment utilisé pour la représentation de séries temporelles. On passe à geom_line deux paramètres : x et y. Les observations sont alors connectées selon l’ordre des valeurs passées en x.\nComme il n’y a pas de données adaptées pour ce type de représentation dans notre jeu de données d’exemple, on va utiliser ici le jeu de données economics inclus dans ggplot2 et représenter l’évolution du taux de chômage aux États-Unis (variable unemploy) dans le temps (variable date) :\n\ndata(\"economics\")\neconomics\n#&gt; # A tibble: 574 × 6\n#&gt;    date         pce    pop psavert uempmed unemploy\n#&gt;    &lt;date&gt;     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 1967-07-01  507. 198712    12.6     4.5     2944\n#&gt;  2 1967-08-01  510. 198911    12.6     4.7     2945\n#&gt;  3 1967-09-01  516. 199113    11.9     4.6     2958\n#&gt;  4 1967-10-01  512. 199311    12.9     4.9     3143\n#&gt;  5 1967-11-01  517. 199498    12.8     4.7     3066\n#&gt;  6 1967-12-01  525. 199657    11.8     4.8     3018\n#&gt;  7 1968-01-01  531. 199808    11.7     5.1     2878\n#&gt;  8 1968-02-01  534. 199920    12.3     4.5     3001\n#&gt;  9 1968-03-01  544. 200056    11.7     4.1     2877\n#&gt; 10 1968-04-01  544  200208    12.3     4.6     2709\n#&gt; # ℹ 564 more rows\n\n\nggplot(economics) +\n    geom_line(aes(x = date, y = unemploy))",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#mappages",
    "href": "ggplot2.html#mappages",
    "title": "6  Les graphiques",
    "section": "6.4 Mappages",
    "text": "6.4 Mappages\nUn mappage, dans ggplot2, est une mise en relation entre un attribut graphique du geom (position, couleur, taille…) et une variable du tableau de données.\nCes mappages sont passés aux différents geom via la fonction aes() (abbréviation d’aesthetic).\n\n6.4.1 Exemples de mappages\nOn a déjà vu les mappages x et y pour un nuage de points. Ceux-ci signifient que la position d’un point donné horizontalement (x) et verticalement (y) dépend de la valeur des variables passées comme arguments x et y dans aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres)\n    )\n\n\n\n\n\n\n\n\nMais on peut ajouter d’autres mappages. Par exemple, color permet de faire varier la couleur des points automatiquement en fonction des valeurs d’une troisième variable. Ainsi, on peut vouloir colorer les points selon le département de la commune correspondante.\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement)\n    )\n\n\n\n\n\n\n\n\nOn peut aussi faire varier la taille des points avec size. Ici, la taille dépend de la population totale de la commune :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot)\n    )\n\n\n\n\n\n\n\n\nOn peut même associer la transparence des points à une variable avec alpha :\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot, alpha = maison)\n    )\n\n\n\n\n\n\n\n\nChaque geom possède sa propre liste de mappages.\n\n\n6.4.2 aes() or not aes() ?\nComme on l’a déjà vu, parfois on souhaite changer un attribut sans le relier à une variable : c’est le cas par exemple si on veut représenter tous les points en rouge. Dans ce cas on utilise toujours l’attribut color, mais comme il ne s’agit pas d’un mappage, on le définit à l’extérieur de la fonction aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres),\n        color = \"red\"\n    )\n\n\n\n\n\n\n\n\nPar contre, si on veut faire varier la couleur en fonction des valeurs prises par une variable, on réalise un mappage, et on doit donc placer l’attribut color à l’intérieur de aes().\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, color = departement)\n    )\n\n\n\n\n\n\n\n\nOn peut mélanger attributs liés à une variable (mappage, donc dans aes()) et attributs constants (donc à l’extérieur). Dans l’exemple suivant, la taille varie en fonction de la variable pop_tot, mais la couleur est constante pour tous les points.\n\nggplot(rp) +\n    geom_point(\n        aes(x = dipl_sup, y = cadres, size = pop_tot),\n        color = \"royalblue\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nLa règle est donc simple mais très importante :\nSi on établit un lien entre les valeurs d’une variable et un attribut graphique, on définit un mappage, et on le déclare dans aes(). Sinon, on modifie l’attribut de la même manière pour tous les points, et on le définit en-dehors de la fonction aes().\n\n\n\n\n6.4.3 geom_bar et position\nUn des mappages possibles de geom_bar est l’attribut fill, qui permet de tracer des barres de couleur différentes selon les modalités d’une deuxième variable :\n\nggplot(rp) +\n    geom_bar(aes(x = departement, fill = pop_cl))\n\n\n\n\n\n\n\n\nL’attribut position de geom_bar permet d’indiquer comment les différentes barres doivent être positionnées. Par défaut l’argument vaut position = \"stack\" et elles sont donc “empilées”. Mais on peut préciser position = \"dodge\" pour les mettre côte à côte.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"dodge\"\n    )\n\n\n\n\n\n\n\n\nOu encore position = \"fill\" pour représenter non plus des effectifs, mais des proportions.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"fill\"\n    )\n\n\n\n\n\n\n\n\nLà encore, on peut utiliser coord_flip() si on souhaite une visualisation avec des barres horizontales.\n\nggplot(rp) +\n    geom_bar(\n        aes(x = departement, fill = pop_cl),\n        position = \"fill\"\n    ) +\n    coord_flip()",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#représentation-de-plusieurs-geom",
    "href": "ggplot2.html#représentation-de-plusieurs-geom",
    "title": "6  Les graphiques",
    "section": "6.5 Représentation de plusieurs geom",
    "text": "6.5 Représentation de plusieurs geom\nOn peut représenter plusieurs geom simultanément sur un même graphique, il suffit de les ajouter à tour de rôle avec l’opérateur +.\nPar exemple, on peut superposer la position des points au-dessus d’un boxplot. On va pour cela ajouter un geom_point après avoir ajouté notre geom_boxplot.\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison)) +\n    geom_point(\n        aes(x = departement, y = maison),\n        col = \"red\", alpha = 0.2\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuand une commande ggplot2 devient longue, il peut être plus lisible de la répartir sur plusieurs lignes. Dans ce cas, il faut penser à placer l’opérateur + en fin de ligne, afin que R comprenne que la commande n’est pas complète et qu’il prenne en compte la suite.\n\n\nPour un résultat un peu plus lisible, on peut remplacer geom_point par geom_jitter, qui disperse les points horizontalement et facilite leur visualisation.\n\nggplot(rp) +\n    geom_boxplot(aes(x = departement, y = maison)) +\n    geom_jitter(\n        aes(x = departement, y = maison),\n        col = \"red\", alpha = 0.2\n    )\n\n\n\n\n\n\n\n\nPour simplifier un peu le code, plutôt que de déclarer les mappages dans chaque geom, on peut les déclarer dans l’appel à ggplot(). Ils seront automatiquement “hérités” par les geom ajoutés (sauf s’ils redéfinissent les mêmes mappages).\n\nggplot(rp, aes(x = departement, y = maison)) +\n    geom_boxplot() +\n    geom_jitter(color = \"red\", alpha = 0.2)\n\n\n\n\n\n\n\n\nAutre exemple, on peut vouloir ajouter à un nuage de points une ligne de régression linéaire à l’aide de geom_smooth :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nEt on peut même superposer une troisième visualisation de la répartition des points dans l’espace avec geom_density2d :\n\nggplot(rp, aes(x = dipl_sup, y = cadres)) +\n    geom_point(alpha = 0.2) +\n    geom_density2d(color = \"red\") +\n    geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nOn peut enfin superposer l’histogramme ainsi que le polygone de fréquences.\n\nggplot(rp) +\n    geom_histogram(aes(x = cadres), binwidth = 5) +\n    geom_freqpoly(aes(x = cadres), binwidth = 5)",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#faceting",
    "href": "ggplot2.html#faceting",
    "title": "6  Les graphiques",
    "section": "6.6 Faceting",
    "text": "6.6 Faceting\nLe faceting permet d’effectuer plusieurs fois le même graphique selon les valeurs d’une ou plusieurs variables qualitatives.\nPar exemple, on a vu qu’on peut représenter l’histogramme du pourcentage de cadres dans nos communes avec le code suivant :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres))\n\n\n\n\n\n\n\n\nOn souhaite comparer cette distribution de la part des cadres selon le département, et donc faire un histogramme pour chacun de ces départements. C’est ce que permettent les fonctions facet_wrap et facet_grid.\nfacet_wrap prend un paramètre de la forme vars(variable), où variable est le nom de la variable en fonction de laquelle on souhaite faire les différents graphiques. Ceux-ci sont alors affichés les uns à côté des autres et répartis automatiquement dans la page.\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_wrap(vars(departement))\n\n\n\n\n\n\n\n\nPour facet_grid, les graphiques sont disposés selon une grille. La fonction prend alors deux arguments, rows et cols, auxquels on passe les variables à afficher en ligne ou en colonne via la fonction vars().\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_grid(rows = vars(departement))\n\n\n\n\n\n\n\n\nUn des intérêts du faceting dans ggplot2 est que tous les graphiques générés ont les mêmes échelles, ce qui permet une comparaison directe.\nEnfin, notons qu’on peut même faire du faceting sur plusieurs variables à la fois. On peut par exemple faire des histogrammes de la répartition de la part des cadres pour chaque croisement des variables departement et pop_cl :\n\nggplot(data = rp) +\n    geom_histogram(aes(x = cadres)) +\n    facet_grid(\n        rows = vars(departement), cols = vars(pop_cl)\n    )\n\n\n\n\n\n\n\n\nL’histogramme en haut à gauche représente la répartition du pourcentage de cadres parmi les communes de 2000 à 3000 habitants dans les Bouches-du-Rhône, etc.",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#ressources",
    "href": "ggplot2.html#ressources",
    "title": "6  Les graphiques",
    "section": "6.7 Ressources",
    "text": "6.7 Ressources\nLa documentation officielle (en anglais) de ggplot2 est très complète et accessible en ligne.\nUne “antisèche” (en anglais) résumant en deux pages l’ensemble des fonctions et arguments et disponible soit directement depuis RStudio (menu Help &gt; Cheatsheets &gt; Data visualization with ggplot2) ou en ligne.\nLes parties Data visualisation et Graphics for communication de l’ouvrage en ligne R for data science, de Hadley Wickham, sont une très bonne introduction à ggplot2.\nPlusieurs ouvrages, toujours en anglais, abordent en détail l’utilisation de ggplot2, en particulier ggplot2: Elegant Graphics for Data Analysis, toujours de Hadley Wickham, et le R Graphics Cookbook de Winston Chang.\nLe site associé à ce dernier ouvrage comporte aussi pas mal d’exemples et d’informations intéressantes.\nEnfin, si ggplot2 présente déjà un très grand nombre de fonctionnalités, il existe aussi un système d’extensions permettant d’ajouter des geom, des thèmes, etc. Le site ggplot2 extensions est une très bonne ressource pour les parcourir et les découvrir, notamment grâce à sa galerie.",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Les graphiques</span>"
    ]
  },
  {
    "objectID": "mesures.html",
    "href": "mesures.html",
    "title": "7  Les mesures",
    "section": "",
    "text": "7.1 Les mesures de tendance centrale",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Les mesures</span>"
    ]
  },
  {
    "objectID": "mesures.html#les-mesures-de-tendance-centrale",
    "href": "mesures.html#les-mesures-de-tendance-centrale",
    "title": "7  Les mesures",
    "section": "",
    "text": "7.1.1 Le mode\nLe mode est la modalité, valeur ou classe possédant la plus grande fréquence. En d’autres mots, c’est la donnée la plus fréquente.\nPuisque le mode se préoccupe seulement de la donnée la plus fréquente, il n’est pas influencé par les valeurs extrêmes.\nLorsque le mode est une classe, il est appelé classe modale.\nLe mode est noté Mo.\nLe langage R ne possède pas de fonction permettant de calculer le mode. La façon la plus simple de le calculer est d’utiliser la fonction table de R.\nPar exemple, si nous voulons connaître le mode de la variable marital de la base de données gss_cat:\n\ntable(gss_cat$marital)\n#&gt; \n#&gt;     No answer Never married     Separated      Divorced       Widowed \n#&gt;            17          5416           743          3383          1807 \n#&gt;       Married \n#&gt;         10117\n\nNous remarquons que le maximum est à la modalité Married avec une fréquence de 10117.\nSi nous nous intéressons au mode d’une variable quantitative discrète comme age de la base de données gss_cat nous obtenons:\n\ntable(gss_cat$age)\n#&gt; \n#&gt;  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37 \n#&gt;  91 249 251 278 298 361 344 396 400 385 387 376 433 407 445 425 425 417 428 438 \n#&gt;  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57 \n#&gt; 426 415 452 434 405 448 432 404 422 435 424 417 430 390 400 396 387 365 384 321 \n#&gt;  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77 \n#&gt; 326 323 338 307 310 292 253 259 231 271 205 201 213 206 189 152 180 179 171 137 \n#&gt;  78  79  80  81  82  83  84  85  86  87  88  89 \n#&gt; 150 135 127 119 105  99 100  75  74  54  57 148\n\nNous remarquons que le maximum est à la valeur 40 avec une fréquence de 452.\nDans le cas d’une variable quantitative continue, pour calculer le mode, il faut commencer par séparer les données en classes. Nous utiliserons les mêmes classes utilisées à la section:\n\ncarat_class = cut(diamonds$carat,\n                  breaks = seq(from = 0, to = 6, by = 1),\n                  right = FALSE)\ntable(carat_class)\n#&gt; carat_class\n#&gt; [0,1) [1,2) [2,3) [3,4) [4,5) [5,6) \n#&gt; 34880 16906  2114    34     5     1\n\nLa classe modale est donc la classe [0,1) avec une fréquence de 34880.\n\n\n7.1.2 La médiane\nLa médiane, notée Md, est la valeur qui sépare une série de données classée en ordre croissant en deux parties égales.\nLa médiane étant la valeur du milieu, elle est la valeur où le pourcentage cumulé atteint 50%.\nPuisque la médiane se préoccupe seulement de déterminer où se situe le centre des données, elle n’est pas influencée par les valeurs extrêmes. Elle est donc une mesure de tendance centrale plus fiable que la moyenne.\n\nImportant : La médiane n’est définie que pour les variables quantitatives. En effet, si vous tentez d’utiliser la médiane pour des données autres que numériques, R vous donnera un message d’erreur.\n\nLa fonction median permet de calculer la médiane en langage R.\nPar exemple, pour calculer la médiane de la variable carat de la base de données diamonds, nous avons:\n\nmedian(diamonds$carat)\n#&gt; [1] 0.7\n\nCeci signifie que 50% des diamants ont une valeur en carat inférieure ou égale à 0.7 et que 50% des diamants ont une valeur en carat supérieure ou égale à 0.7.\nNous pouvons aussi obtenir que la médiane de la variable price de la base de données diamonds est donnée par:\n\nmedian(diamonds$price)\n#&gt; [1] 2401\n\n\n\n7.1.3 La moyenne\nLa moyenne est la valeur qui pourrait remplacer chacune des données d’une série pour que leur somme demeure identique. Intuitivement, elle représente le centre d’équilibre d’une série de données. La somme des distances qui sépare les données plus petites que la moyenne devrait être la même que la somme des distances qui sépare les données plus grandes.\n\nImportant : La moyenne n’est définie que pour les variables quantitatives. En effet, si vous tentez d’utiliser la moyenne pour des données autres que numériques, R vous donnera un message d’erreur.\n\nLa fonction mean permet de calculer la moyenne en langage R.\nPar exemple, pour calculer la moyenne de la variable carat de la base de données diamonds, nous avons:\n\nmean(diamonds$carat)\n#&gt; [1] 0.7979397\n\nNous pouvons aussi obtenir que la moyenne de la variable price de la base de données diamonds est donnée par:\n\nmean(diamonds$price)\n#&gt; [1] 3932.8",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Les mesures</span>"
    ]
  },
  {
    "objectID": "mesures.html#les-mesures-de-dispersion",
    "href": "mesures.html#les-mesures-de-dispersion",
    "title": "7  Les mesures",
    "section": "7.2 Les mesures de dispersion",
    "text": "7.2 Les mesures de dispersion\nLes mesures de tendance centrale (mode, moyenne et médiane) ne permettent pas de déterminer si une série de données est principalement située autour de son centre, ou si au contraire elle est très dispersée.\nLes mesures de dispersion, elles, permettent de déterminer si une série de données est centralisée autour de sa moyenne, ou si elle est au contraire très dispersée.\nLes mesures de dispersion sont l’étendue, la variance, l’écart-type et le coefficient de variation.\n\n7.2.1 L’étendue\nLa première mesure de dispersion, l’étendue, est la différence entre la valeur maximale et la valeur minimale.\nL’étendue ne tenant compte que du maximum et du minimum, elle est grandement influencée par les valeurs extrêmes. Elle est donc une mesure de dispersion peu fiable.\nLa fonction range permet de calculer l’étendue d’une variable en langage R.\nPar exemple, pour calculer l’étendue de la variable carat de la base de données diamonds, nous avons:\n\nrange(diamonds$carat)\n#&gt; [1] 0.20 5.01\n\nNous pouvons donc calculer l’étendue de la variable carat en soustrayant les deux valeurs obtenues par la fonction range, c’est-à-dire que l’étendue est 5.01-0.2 = 4.81.\n\n\n7.2.2 La variance\nLa variance sert principalement à calculer l’écart-type, la mesure de dispersion la plus connue.\n\nAttention : Les unités de la variance sont des unités2.\n\nLa fonction var permet de calculer la variance d’une variable en langage R.\nPar exemple, pour calculer la variance de la variable carat de la base de données diamonds, nous avons:\n\nvar(diamonds$carat)\n#&gt; [1] 0.2246867\n\nCeci signifie que la variance de la variable carat est 0.2246867 carat2.\n\n\n7.2.3 L’écart-type\nL’écart-type est la mesure de dispersion la plus couramment utilisée. Il peut être vu comme la « moyenne » des écarts entre les données et la moyenne.\nPuisque l’écart-type tient compte de chacune des données, il est une mesure de dispersion beaucoup plus fiable que l’étendue.\nIl est défini comme la racine carrée de la variance.\nLa fonction sd permet de calculer l’’écart-type d’une variable en langage R.\nPar exemple, pour calculer l’écart-type de la variable carat de la base de données diamonds, nous avons:\n\nsd(diamonds$carat)\n#&gt; [1] 0.4740112\n\nCeci signifie que l’écart-type de la variable carat est 0.4740112 carat.\n\n\n7.2.4 Le coefficient de variation\nLe coefficient de variation, noté C. V., est calculé comme suit :\n\\[\\begin{equation}\nC.V. = \\dfrac{\\text{ecart-type}}{\\text{moyenne}}\\times 100\\%\n\\end{equation}\\]\nSi le coefficient est inférieur à 15%, les données sont dites homogènes. Cela veut dire que les données sont situées près les unes des autres.\nDans le cas contraire, les données sont dites hétérogènes. Cela veut dire que les données sont très dispersées.\n\nImportant : Le coefficient de variation ne possède pas d’unité, outre le symbole de pourcentage.\n\nIl n’existe pas de fonctions en R permettant de calculer directement le coefficient de variation. Par contre, nous pouvons utiliser en conjonction les fonctions sd et mean pour le calculer.\nPar exemple, pour calculer le coefficient de variation de la variable carat de la base de données diamonds, nous avons:\n\nsd(diamonds$carat)/mean(diamonds$carat)*100\n#&gt; [1] 59.40439\n\nLe C.V. de la variable carat est donc 59.4043906 %, ce qui signifie que les données sont hétérogènes, car le coefficient de variation est plus grand que 15%.",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Les mesures</span>"
    ]
  },
  {
    "objectID": "mesures.html#les-mesures-de-position",
    "href": "mesures.html#les-mesures-de-position",
    "title": "7  Les mesures",
    "section": "7.3 Les mesures de position",
    "text": "7.3 Les mesures de position\nLes mesures de position permettent de situer une donnée par rapport aux autres. Les différentes mesures de position sont la cote Z, les quantiles et les rangs.\nTout comme les mesures de dispersion, celles-ci ne sont définies que pour une variable quantitative.\n\n7.3.1 La cote z\nCette mesure de position se base sur la moyenne et l’écart-type.\nLa cote Z d’une donnée x est calculée comme suit :\n\\[\\begin{equation}\nZ = \\dfrac{x-\\text{moyenne}}{\\text{ecart-type}}\n\\end{equation}\\]\n\nImportant : La cote z ne possède pas d’unités.\n\nUne cote Z peut être positive, négative ou nulle.\n\n\n\nCote Z\nInterprétation\n\n\n\n\nZ&gt;0\ndonnée supérieure à la moyenne\n\n\nZ&lt;0\ndonnée inférieure à la moyenne\n\n\nZ=0\ndonnée égale à la moyenne\n\n\n\nIl n’existe pas de fonctions en R permettant de calculer directement la cote Z. Par contre, nous pouvons utiliser en conjonction les fonctions sd et mean pour la calculer.\nPar exemple, si nous voulons calculer la cote Z d’un diamant de 3 carats, nous avons:\n\n(3-mean(diamonds$carat))/sd(diamonds$carat)\n#&gt; [1] 4.645587\n\n\n\n7.3.2 Les quantiles\nUn quantile est une donnée qui correspond à un certain pourcentage cumulé.\nParmi les quantiles, on distingue les quartiles, les quintiles, les déciles et les centiles.\n\nLes quartiles Q1, Q2 et Q3, séparent les données en quatre parties égales. Environ 25% des données sont inférieures ou égales à Q1. Environ 50% des données sont inférieures ou égales à Q2. Environ 75% des données sont inférieures ou égales à Q3.\nLes quintiles V1, V2, V3 et V4, séparent les données en cinq parties égales. Environ 20% des données sont inférieures ou égales à V1. Environ 40% des données sont inférieures ou égales à V2. Etc.\nLes déciles D1, D2, …, D8 et D9, séparent les données en dix parties égales. Environ 10% des données sont inférieures ou égales à D1. Environ 20% des données sont inférieures ou égales à D2. Etc.\nLes centiles C1, C2, …, C98 et C99, séparent les données en cent parties égales. Environ 1% des données sont inférieures ou égales à C1. Environ 2% des données sont inférieures ou égales à C2. Etc.\n\n\nIl est utile de noter que certains quantiles se recoupent.\n\nLa fonction quantile permet de calculer n’importe quel quantile d’une variable en langage R. Il suffit d’indiquer la variable étudiée ainsi que le pourcentage du quantile voulu.\nPar exemple, si nous voulons calculer D1 pour la variable carat, nous allons utiliser la fonction quantile avec une probabilité de 0,1.\n\nquantile(diamonds$carat, 0.1)\n#&gt;  10% \n#&gt; 0.31\n\nCeci implique que 10% des diamants ont une valeur en carat inférieure ou égale à 0.31 carat.\nNous pouvons calculer le troisième quartile Q3 de la variable price en utilisant la fonction quantile avec une probabilité de 0,75.\n\nquantile(diamonds$price, 0.75)\n#&gt;     75% \n#&gt; 5324.25\n\nCeci implique que 75% des diamants ont un prix en dollars inférieur ou égal à 5324.25 $.\n\n\n7.3.3 La commande summary\nLa commande summary produit un sommaire contenant six mesures importantes:\n\nMin : le minimum de la variable\n1st Qu.: Le premier quartile, Q1, de la variable\nMedian : La médiane de la variable\nMean : La moyenne de la variable\n3rd Qu. : Le troisième quartile, Q3, de la variable\nMax : Le maximum de la variable\n\nNous pouvons donc produire le sommaire de la variable price de la base de données diamonds de la façon suivante:\n\nsummary(diamonds$price)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;     326     950    2401    3933    5324   18823\n\n\n\n7.3.4 Le rang centile\nUn rang centile représente le pourcentage cumulé, exprimé en nombre entier, qui correspond à une certaine donnée. Nous déterminerons les rangs centiles pour les variables continues seulement.\nLes rangs centiles sont donc exactement l’inverse des centiles.\nIl n’existe pas de fonctions dans R permettant de trouver directement le rang centile, mais il est facile d’utiliser la fonction mean pour le trouver.\nPar exemple, si nous voulons trouver le rang centile d’un diamant qui coûte 500$, il suffit d’utiliser la commande suivante. La commande calcule la moyenne de toutes les valeurs en dollars des diamants coûtant 500$ ou moins.\n\nfloor(mean(diamonds$price&lt;=500)*100)\n#&gt; [1] 3\n\nCeci signifie que pour un diamant de 500$, il y a 3 % des diamants qui ont une valeur égale ou inférieure.",
    "crumbs": [
      "Les statistiques descriptives",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Les mesures</span>"
    ]
  },
  {
    "objectID": "estimation.html",
    "href": "estimation.html",
    "title": "8  L’estimation de paramètres",
    "section": "",
    "text": "8.1 L’intervalle de confiance sur une moyenne\nPour trouver un intervalle de confiance sur une moyenne, nous utilisons la fonction t_test.\nLes quatres arguments nécessaires sont:\nPar exemple, si on veut trouver un intervalle de confiance à 95% pour la moyenne de la variable age, nous utilisons:\nt_test( x = gss, \n        response = age, \n        alternative = \"two-sided\", \n        conf_level = 0.95)\n#&gt; # A tibble: 1 × 7\n#&gt;   statistic  t_df   p_value alternative estimate lower_ci upper_ci\n#&gt;       &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1      67.6   499 2.42e-253 two.sided       40.3     39.1     41.4\nLa borne inférieure de l’intervalle de confiance est donnée par la variable lower_ci et la borne supérieure par la variable upper_ci. Dans notre test, nous avons donc un intervalle de confiance entre 39.095674 et 41.436326.",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>L'estimation de paramètres</span>"
    ]
  },
  {
    "objectID": "estimation.html#lintervalle-de-confiance-sur-une-moyenne",
    "href": "estimation.html#lintervalle-de-confiance-sur-une-moyenne",
    "title": "8  L’estimation de paramètres",
    "section": "",
    "text": "x: la base de données à utiliser, sous forme de tibble.\nresponse: la variable quantitative dont on veut connaître l’intervalle de confiance pour la moyenne.\nalternative: pour un intervalle de confiance, on utilise toujours la valeur two-sided.\nconf_level: un niveau de confiance entre 0 et 1.",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>L'estimation de paramètres</span>"
    ]
  },
  {
    "objectID": "estimation.html#lintervalle-de-confiance-sur-une-proportion",
    "href": "estimation.html#lintervalle-de-confiance-sur-une-proportion",
    "title": "8  L’estimation de paramètres",
    "section": "8.2 L’intervalle de confiance sur une proportion",
    "text": "8.2 L’intervalle de confiance sur une proportion\nPour trouver un intervalle de confiance sur une proportion, nous utilisons la fonction prop_test.\nLes cinq arguments nécessaires sont:\n\nx: la base de données à utiliser, sous forme de tibble.\nresponse: la variable quantitative dont on veut connaître l’intervalle de confiance pour la proportion.\nsuccess: la modalité de la variable que nous considérons comme un succès.\nalternative: pour un intervalle de confiance, on utilise toujours la valeur two-sided.\nconf_level: un niveau de confiance entre 0 et 1.\n\nPar exemple, si on veut trouver un intervalle de confiance à 95% pour la proportion de female de la variable age, nous utilisons:\n\nprop_test(  x = gss, \n            response = sex, \n            success = \"female\",\n            alternative = \"two-sided\", \n            conf_level = 0.95)\n#&gt; No `p` argument was hypothesized, so the test will assume a null hypothesis `p\n#&gt; = .5`.\n#&gt; # A tibble: 1 × 6\n#&gt;   statistic chisq_df p_value alternative lower_ci upper_ci\n#&gt;       &lt;dbl&gt;    &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1      1.25        1   0.264 two.sided      0.430    0.519\n\n\n#&gt; No `p` argument was hypothesized, so the test will assume a null hypothesis `p\n#&gt; = .5`.\n\nLa borne inférieure de l’intervalle de confiance est donnée par la variable lower_ci et la borne supérieure par la variable upper_ci. Dans notre test, nous avons donc un intervalle de confiance entre 0.4296103 et 0.5187952.",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>L'estimation de paramètres</span>"
    ]
  },
  {
    "objectID": "tests-hypotheses.html",
    "href": "tests-hypotheses.html",
    "title": "9  Les tests d’hypothèses",
    "section": "",
    "text": "9.1 Les tests d’hypothèses sur une moyenne\nPour effectuer un test d’hypothèses sur une moyenne, nous utilisons la fonction t_test.\nLes quatres arguments nécessaires sont:\nPar exemple, si on veut tester si la moyenne de la variable age est plus grande que 39 ans, à un niveau de confiance de 98%, nous utilisons:\nt_test( x = gss,\n        response = age,\n        mu = 39,\n        alternative = \"greater\"\n)\n#&gt; # A tibble: 1 × 7\n#&gt;   statistic  t_df p_value alternative estimate lower_ci upper_ci\n#&gt;       &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1      2.13   499  0.0170 greater         40.3     39.3      Inf\nLa variable p_value nous permet de conserver ou de rejetter \\(H_0\\). En effet, dans notre cas, la valeur est de 0.0170242 qui est plus petite que le risque d’erreur de 2% (associé au niveau de confiance de 98%). On rejette donc \\(H_0\\) et on accepte \\(H_1\\), l’âge moyen est plus grand que 39 ans.",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les tests d'hypothèses</span>"
    ]
  },
  {
    "objectID": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-moyenne",
    "href": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-moyenne",
    "title": "9  Les tests d’hypothèses",
    "section": "",
    "text": "x: la base de données à utiliser, sous forme de tibble.\nresponse: la variable dont on veut tester l’hypothèse.\nmu: la valeur de la moyenne à l’hypothèse \\(H_0\\).\nalternative:\n\nless: pour un test unilatéral à gauche\ntwo-sided: pour un test bilatéral\ngreater: pour un test unilatéral à droite",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les tests d'hypothèses</span>"
    ]
  },
  {
    "objectID": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-proportion",
    "href": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-proportion",
    "title": "9  Les tests d’hypothèses",
    "section": "9.2 Les tests d’hypothèses sur une proportion",
    "text": "9.2 Les tests d’hypothèses sur une proportion\nPour effectuer un test d’hypothèses sur une proportion, nous utilisons la fonction prop_test.\nLes quatres arguments nécessaires sont:\n\nx: la base de données à utiliser, sous forme de tibble.\nresponse: la variable dont on veut connaître l’intervalle de confiance pour la proportion.\nsuccess: la modalité de la variable que nous considérons comme un succès.\nalternative:\n\nless: pour un test unilatéral à gauche\ntwo-sided: pour un test bilatéral\ngreater: pour un test unilatéral à droite\n\n\nPar exemple, si on veut tester si la proportion de female de la variable sex est plus petite que 51%, à un niveau de confiance de 99%, nous utilisons:\n\nprop_test(  x = gss, \n            response = sex, \n            success = \"female\",\n            alternative = \"less\", \n            p = 0.51)\n#&gt; # A tibble: 1 × 4\n#&gt;   statistic chisq_df p_value alternative\n#&gt;       &lt;dbl&gt;    &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;      \n#&gt; 1      2.45        1  0.0587 less\n\nLa variable p_value nous permet de conserver ou de rejetter \\(H_0\\). En effet, dans notre cas, la valeur est de 0.0587257 qui est plus grande que le risque d’erreur de 1% (associé au niveau de confiance de 99%). On conserve donc \\(H_0\\), la proportion de femmes ne semble pas être plus petite que 51%.",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les tests d'hypothèses</span>"
    ]
  },
  {
    "objectID": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-différence-de-moyennes",
    "href": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-différence-de-moyennes",
    "title": "9  Les tests d’hypothèses",
    "section": "9.3 Les tests d’hypothèses sur une différence de moyennes",
    "text": "9.3 Les tests d’hypothèses sur une différence de moyennes\n\nt_test(x = gss,\n       response = age,\n       explanatory = sex,\n       alternative = \"two-sided\",\n       mu = 1)\n#&gt; Warning: The statistic is based on a difference or ratio; by default, for\n#&gt; difference-based statistics, the explanatory variable is subtracted in the\n#&gt; order \"male\" - \"female\", or divided in the order \"male\" / \"female\" for\n#&gt; ratio-based statistics. To specify this order yourself, supply `order =\n#&gt; c(\"male\", \"female\")`.\n#&gt; # A tibble: 1 × 7\n#&gt;   statistic  t_df p_value alternative estimate lower_ci upper_ci\n#&gt;       &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1    -0.213  498.   0.831 two.sided      0.746    -1.59     3.08",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les tests d'hypothèses</span>"
    ]
  },
  {
    "objectID": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-différence-de-proportions",
    "href": "tests-hypotheses.html#les-tests-dhypothèses-sur-une-différence-de-proportions",
    "title": "9  Les tests d’hypothèses",
    "section": "9.4 Les tests d’hypothèses sur une différence de proportions",
    "text": "9.4 Les tests d’hypothèses sur une différence de proportions\n\nprop_test(gss,\n          response = college,\n          explanatory = sex,\n          alternative = \"two-sided\")\n#&gt; Warning: The statistic is based on a difference or ratio; by default, for\n#&gt; difference-based statistics, the explanatory variable is subtracted in the\n#&gt; order \"male\" - \"female\", or divided in the order \"male\" / \"female\" for\n#&gt; ratio-based statistics. To specify this order yourself, supply `order =\n#&gt; c(\"male\", \"female\")`.\n#&gt; # A tibble: 1 × 6\n#&gt;   statistic chisq_df p_value alternative lower_ci upper_ci\n#&gt;       &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 0.0000204        1   0.996 two.sided    -0.0834   0.0918",
    "crumbs": [
      "L'estimation et les tests d'hypothèses",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Les tests d'hypothèses</span>"
    ]
  }
]